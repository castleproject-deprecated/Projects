//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer ModelSerializer for DomainClass Model.
	/// </summary>
	public partial class ModelSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelSerializer Constructor
		/// </summary>
		public ModelSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Model.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"model"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Model.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Model in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Model instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Model element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Model instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Model instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			Model instanceOfModel = element as Model;
			global::System.Diagnostics.Debug.Assert(instanceOfModel != null, "Expecting an instance of Model");
	
			// UseNullables
			if (!serializationContext.Result.Failed)
			{
				string attribUseNullables = reader.GetAttribute("useNullables");
				if (attribUseNullables != null)
				{
					NullableUsage valueOfUseNullables;
					if (DslModeling::SerializationUtilities.TryGetValue<NullableUsage>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUseNullables), out valueOfUseNullables))
					{
						instanceOfModel.UseNullables = valueOfUseNullables;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useNullables", typeof(NullableUsage), attribUseNullables);
					}
				}
			}
			// CaseOfPrivateFields
			if (!serializationContext.Result.Failed)
			{
				string attribCaseOfPrivateFields = reader.GetAttribute("caseOfPrivateFields");
				if (attribCaseOfPrivateFields != null)
				{
					FieldCase valueOfCaseOfPrivateFields;
					if (DslModeling::SerializationUtilities.TryGetValue<FieldCase>(DslModeling::SerializationUtilities.UnescapeXmlString(attribCaseOfPrivateFields), out valueOfCaseOfPrivateFields))
					{
						instanceOfModel.CaseOfPrivateFields = valueOfCaseOfPrivateFields;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "caseOfPrivateFields", typeof(FieldCase), attribCaseOfPrivateFields);
					}
				}
			}
			// GenerateMonoRailProject
			if (!serializationContext.Result.Failed)
			{
				string attribGenerateMonoRailProject = reader.GetAttribute("generateMonoRailProject");
				if (attribGenerateMonoRailProject != null)
				{
					global::System.Boolean valueOfGenerateMonoRailProject;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribGenerateMonoRailProject), out valueOfGenerateMonoRailProject))
					{
						instanceOfModel.GenerateMonoRailProject = valueOfGenerateMonoRailProject;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "generateMonoRailProject", typeof(global::System.Boolean), attribGenerateMonoRailProject);
					}
				}
			}
			// MonoRailProjectName
			if (!serializationContext.Result.Failed)
			{
				string attribMonoRailProjectName = reader.GetAttribute("monoRailProjectName");
				if (attribMonoRailProjectName != null)
				{
					global::System.String valueOfMonoRailProjectName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribMonoRailProjectName), out valueOfMonoRailProjectName))
					{
						instanceOfModel.MonoRailProjectName = valueOfMonoRailProjectName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "monoRailProjectName", typeof(global::System.String), attribMonoRailProjectName);
					}
				}
			}
			// MonoRailProjectPath
			if (!serializationContext.Result.Failed)
			{
				string attribMonoRailProjectPath = reader.GetAttribute("monoRailProjectPath");
				if (attribMonoRailProjectPath != null)
				{
					global::System.String valueOfMonoRailProjectPath;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribMonoRailProjectPath), out valueOfMonoRailProjectPath))
					{
						instanceOfModel.MonoRailProjectPath = valueOfMonoRailProjectPath;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "monoRailProjectPath", typeof(global::System.String), attribMonoRailProjectPath);
					}
				}
			}
			// MonoRailDefaultLayout
			if (!serializationContext.Result.Failed)
			{
				string attribMonoRailDefaultLayout = reader.GetAttribute("monoRailDefaultLayout");
				if (attribMonoRailDefaultLayout != null)
				{
					global::System.String valueOfMonoRailDefaultLayout;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribMonoRailDefaultLayout), out valueOfMonoRailDefaultLayout))
					{
						instanceOfModel.MonoRailDefaultLayout = valueOfMonoRailDefaultLayout;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "monoRailDefaultLayout", typeof(global::System.String), attribMonoRailDefaultLayout);
					}
				}
			}
			// MonoRailDefaultRescue
			if (!serializationContext.Result.Failed)
			{
				string attribMonoRailDefaultRescue = reader.GetAttribute("monoRailDefaultRescue");
				if (attribMonoRailDefaultRescue != null)
				{
					global::System.String valueOfMonoRailDefaultRescue;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribMonoRailDefaultRescue), out valueOfMonoRailDefaultRescue))
					{
						instanceOfModel.MonoRailDefaultRescue = valueOfMonoRailDefaultRescue;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "monoRailDefaultRescue", typeof(global::System.String), attribMonoRailDefaultRescue);
					}
				}
			}
			// MonoRailViewFileExtension
			if (!serializationContext.Result.Failed)
			{
				string attribMonoRailViewFileExtension = reader.GetAttribute("monoRailViewFileExtension");
				if (attribMonoRailViewFileExtension != null)
				{
					global::System.String valueOfMonoRailViewFileExtension;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribMonoRailViewFileExtension), out valueOfMonoRailViewFileExtension))
					{
						instanceOfModel.MonoRailViewFileExtension = valueOfMonoRailViewFileExtension;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "monoRailViewFileExtension", typeof(global::System.String), attribMonoRailViewFileExtension);
					}
				}
			}
			// UseGenerics
			if (!serializationContext.Result.Failed)
			{
				string attribUseGenerics = reader.GetAttribute("useGenerics");
				if (attribUseGenerics != null)
				{
					global::System.Boolean valueOfUseGenerics;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUseGenerics), out valueOfUseGenerics))
					{
						instanceOfModel.UseGenerics = valueOfUseGenerics;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useGenerics", typeof(global::System.Boolean), attribUseGenerics);
					}
				}
			}
			// UseBaseClass
			if (!serializationContext.Result.Failed)
			{
				string attribUseBaseClass = reader.GetAttribute("useBaseClass");
				if (attribUseBaseClass != null)
				{
					global::System.Boolean valueOfUseBaseClass;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUseBaseClass), out valueOfUseBaseClass))
					{
						instanceOfModel.UseBaseClass = valueOfUseBaseClass;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useBaseClass", typeof(global::System.Boolean), attribUseBaseClass);
					}
				}
			}
			// BaseClassName
			if (!serializationContext.Result.Failed)
			{
				string attribBaseClassName = reader.GetAttribute("baseClassName");
				if (attribBaseClassName != null)
				{
					global::System.String valueOfBaseClassName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribBaseClassName), out valueOfBaseClassName))
					{
						instanceOfModel.BaseClassName = valueOfBaseClassName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "baseClassName", typeof(global::System.String), attribBaseClassName);
					}
				}
			}
			// GeneratesDoubleDerived
			if (!serializationContext.Result.Failed)
			{
				string attribGeneratesDoubleDerived = reader.GetAttribute("generatesDoubleDerived");
				if (attribGeneratesDoubleDerived != null)
				{
					global::System.Boolean valueOfGeneratesDoubleDerived;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribGeneratesDoubleDerived), out valueOfGeneratesDoubleDerived))
					{
						instanceOfModel.GeneratesDoubleDerived = valueOfGeneratesDoubleDerived;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "generatesDoubleDerived", typeof(global::System.Boolean), attribGeneratesDoubleDerived);
					}
				}
			}
			// DoubleDerivedNameSuffix
			if (!serializationContext.Result.Failed)
			{
				string attribDoubleDerivedNameSuffix = reader.GetAttribute("doubleDerivedNameSuffix");
				if (attribDoubleDerivedNameSuffix != null)
				{
					global::System.String valueOfDoubleDerivedNameSuffix;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDoubleDerivedNameSuffix), out valueOfDoubleDerivedNameSuffix))
					{
						instanceOfModel.DoubleDerivedNameSuffix = valueOfDoubleDerivedNameSuffix;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "doubleDerivedNameSuffix", typeof(global::System.String), attribDoubleDerivedNameSuffix);
					}
				}
			}
			// UseGeneratedCodeAttribute
			if (!serializationContext.Result.Failed)
			{
				string attribUseGeneratedCodeAttribute = reader.GetAttribute("useGeneratedCodeAttribute");
				if (attribUseGeneratedCodeAttribute != null)
				{
					global::System.Boolean valueOfUseGeneratedCodeAttribute;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUseGeneratedCodeAttribute), out valueOfUseGeneratedCodeAttribute))
					{
						instanceOfModel.UseGeneratedCodeAttribute = valueOfUseGeneratedCodeAttribute;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useGeneratedCodeAttribute", typeof(global::System.Boolean), attribUseGeneratedCodeAttribute);
					}
				}
			}
			// Target
			if (!serializationContext.Result.Failed)
			{
				string attribTarget = reader.GetAttribute("target");
				if (attribTarget != null)
				{
					CodeGenerationTarget valueOfTarget;
					if (DslModeling::SerializationUtilities.TryGetValue<CodeGenerationTarget>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTarget), out valueOfTarget))
					{
						instanceOfModel.Target = valueOfTarget;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "target", typeof(CodeGenerationTarget), attribTarget);
					}
				}
			}
			// AssemblyPath
			if (!serializationContext.Result.Failed)
			{
				string attribAssemblyPath = reader.GetAttribute("assemblyPath");
				if (attribAssemblyPath != null)
				{
					global::System.String valueOfAssemblyPath;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribAssemblyPath), out valueOfAssemblyPath))
					{
						instanceOfModel.AssemblyPath = valueOfAssemblyPath;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "assemblyPath", typeof(global::System.String), attribAssemblyPath);
					}
				}
			}
			// ActiveRecordAssemblyName
			if (!serializationContext.Result.Failed)
			{
				string attribActiveRecordAssemblyName = reader.GetAttribute("activeRecordAssemblyName");
				if (attribActiveRecordAssemblyName != null)
				{
					global::System.String valueOfActiveRecordAssemblyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribActiveRecordAssemblyName), out valueOfActiveRecordAssemblyName))
					{
						instanceOfModel.ActiveRecordAssemblyName = valueOfActiveRecordAssemblyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "activeRecordAssemblyName", typeof(global::System.String), attribActiveRecordAssemblyName);
					}
				}
			}
			// NHibernateAssemblyName
			if (!serializationContext.Result.Failed)
			{
				string attribNHibernateAssemblyName = reader.GetAttribute("nHibernateAssemblyName");
				if (attribNHibernateAssemblyName != null)
				{
					global::System.String valueOfNHibernateAssemblyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribNHibernateAssemblyName), out valueOfNHibernateAssemblyName))
					{
						instanceOfModel.NHibernateAssemblyName = valueOfNHibernateAssemblyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "nHibernateAssemblyName", typeof(global::System.String), attribNHibernateAssemblyName);
					}
				}
			}
			// RelateWithActiwFile
			if (!serializationContext.Result.Failed)
			{
				string attribRelateWithActiwFile = reader.GetAttribute("relateWithActiwFile");
				if (attribRelateWithActiwFile != null)
				{
					global::System.Boolean valueOfRelateWithActiwFile;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribRelateWithActiwFile), out valueOfRelateWithActiwFile))
					{
						instanceOfModel.RelateWithActiwFile = valueOfRelateWithActiwFile;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "relateWithActiwFile", typeof(global::System.Boolean), attribRelateWithActiwFile);
					}
				}
			}
			// UseVirtualProperties
			if (!serializationContext.Result.Failed)
			{
				string attribUseVirtualProperties = reader.GetAttribute("useVirtualProperties");
				if (attribUseVirtualProperties != null)
				{
					global::System.Boolean valueOfUseVirtualProperties;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUseVirtualProperties), out valueOfUseVirtualProperties))
					{
						instanceOfModel.UseVirtualProperties = valueOfUseVirtualProperties;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useVirtualProperties", typeof(global::System.Boolean), attribUseVirtualProperties);
					}
				}
			}
			// Namespace
			if (!serializationContext.Result.Failed)
			{
				string attribNamespace = reader.GetAttribute("namespace");
				if (attribNamespace != null)
				{
					global::System.String valueOfNamespace;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribNamespace), out valueOfNamespace))
					{
						instanceOfModel.Namespace = valueOfNamespace;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "namespace", typeof(global::System.String), attribNamespace);
					}
				}
			}
			// ImplementINotifyPropertyChanged
			if (!serializationContext.Result.Failed)
			{
				string attribImplementINotifyPropertyChanged = reader.GetAttribute("implementINotifyPropertyChanged");
				if (attribImplementINotifyPropertyChanged != null)
				{
					global::System.Boolean valueOfImplementINotifyPropertyChanged;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribImplementINotifyPropertyChanged), out valueOfImplementINotifyPropertyChanged))
					{
						instanceOfModel.ImplementINotifyPropertyChanged = valueOfImplementINotifyPropertyChanged;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "implementINotifyPropertyChanged", typeof(global::System.Boolean), attribImplementINotifyPropertyChanged);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Model instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			Model instanceOfModel = element as Model;
			global::System.Diagnostics.Debug.Assert(instanceOfModel != null, "Expecting an instance of Model!");
	
			// Read properties serialized as nested XML elements.
			if (!serializationContext.Result.Failed)
				ReadPropertiesFromElements(serializationContext, instanceOfModel, reader);
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfModel, reader);
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as nested XML elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element, but it can be either a property 
		/// or a child element. 
		/// This method will read as many properties as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered ("unknown" means it's not a property. It can be either a bogus tag, or
		///    a child model element). In this case, this method will position the reader at the open tag of the unknown element. This
		///    implies the if the first child XML element is unknown, this method should return immediately and do nothing.
		/// 2) When all properties are read. In this case, the reader will be positioned at the next tag, which is either the open tag
		///    of the next sibling (which can be the open tag of a child model element), or the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Model instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		private static void ReadPropertiesFromElements(DslModeling::SerializationContext serializationContext, Model element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "additionalImports":	// AdditionalImports
						if (reader.IsEmptyElement)
						{	// No serialized value, must be default one.
							DslModeling::SerializationUtilities.Skip(reader);  // Skip this tag.
						}
						else
						{
							string strAdditionalImports = reader.ReadInnerXml();
							global::System.Collections.Generic.List<Altinoren.ActiveWriter.Import> valueOfAdditionalImports;
							if (DslModeling::SerializationUtilities.TryGetValue<global::System.Collections.Generic.List<Altinoren.ActiveWriter.Import>>(DslModeling::SerializationUtilities.UnescapeXmlString(strAdditionalImports), out valueOfAdditionalImports))
							{
								element.AdditionalImports = valueOfAdditionalImports;
							}
							else
							{	// Invalid property value, ignored.
								ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "additionalImports", typeof(global::System.Collections.Generic.List<Altinoren.ActiveWriter.Import>), strAdditionalImports);
							}
	
							DslModeling::SerializationUtilities.SkipToNextElement(reader);
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
	        /// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies the if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory Model instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, Model element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "classes":	// Relationship "ModelHasClass"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <classes>
							ReadModelHasClassInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </classes>
						}
						break;
					case "nestedClasses":	// Relationship "ModelHasNestedClasses"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <nestedClasses>
							ReadModelHasNestedClassesInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </nestedClasses>
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ModelHasClass.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Model instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadModelHasClassInstances(DslModeling::SerializationContext serializationContext, Model element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newModelClassOfModelHasClassSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newModelClassOfModelHasClassSerializer != null, "Cannot find serializer for ModelClass!");
				ModelClass newModelClassOfModelHasClass = newModelClassOfModelHasClassSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ModelClass;
				if (newModelClassOfModelHasClass != null)
				{
					element.Classes.Add(newModelClassOfModelHasClass);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelClassOfModelHasClass.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelClassOfModelHasClass.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newModelClassOfModelHasClass, reader);
				}
				else
				{
					global::System.Type typeofModelHasClass = typeof(ModelHasClass);
					DslModeling::DomainRelationshipXmlSerializer newModelHasClassSerializer = serializationContext.Directory.GetSerializer(ModelHasClass.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newModelHasClassSerializer != null, "Cannot find serializer for ModelHasClass!");
					ModelHasClass newModelHasClass = newModelHasClassSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ModelHasClass;
					if (newModelHasClass != null)
					{
						if (newModelHasClass.GetType() == typeofModelHasClass)
						{	// The relationship should be serialized in short-form.
							ActiveWriterSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(ModelHasClass));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newModelHasClass, ModelHasClass.ModelDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelHasClass.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelHasClass.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newModelHasClass, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ModelHasNestedClasses.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Model instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadModelHasNestedClassesInstances(DslModeling::SerializationContext serializationContext, Model element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newNestedClassOfModelHasNestedClassesSerializer = serializationContext.Directory.GetSerializer(NestedClass.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newNestedClassOfModelHasNestedClassesSerializer != null, "Cannot find serializer for NestedClass!");
				NestedClass newNestedClassOfModelHasNestedClasses = newNestedClassOfModelHasNestedClassesSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as NestedClass;
				if (newNestedClassOfModelHasNestedClasses != null)
				{
					element.NestedClasses.Add(newNestedClassOfModelHasNestedClasses);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newNestedClassOfModelHasNestedClasses.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newNestedClassOfModelHasNestedClasses.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newNestedClassOfModelHasNestedClasses, reader);
				}
				else
				{
					global::System.Type typeofModelHasNestedClasses = typeof(ModelHasNestedClasses);
					DslModeling::DomainRelationshipXmlSerializer newModelHasNestedClassesSerializer = serializationContext.Directory.GetSerializer(ModelHasNestedClasses.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newModelHasNestedClassesSerializer != null, "Cannot find serializer for ModelHasNestedClasses!");
					ModelHasNestedClasses newModelHasNestedClasses = newModelHasNestedClassesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ModelHasNestedClasses;
					if (newModelHasNestedClasses != null)
					{
						if (newModelHasNestedClasses.GetType() == typeofModelHasNestedClasses)
						{	// The relationship should be serialized in short-form.
							ActiveWriterSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(ModelHasNestedClasses));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newModelHasNestedClasses, ModelHasNestedClasses.ModelDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelHasNestedClasses.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelHasNestedClasses.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newModelHasNestedClasses, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Model based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Model, a new Model instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Model instance, or null if the reader is not pointing to a serialized Model instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Model" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Model".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ModelSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Model based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Model.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Model instance should be created.</param>	
		/// <returns>Created Model instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (idStr == null)
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					ActiveWriterSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new Model(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Model, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Model.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Model.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Model itself) instance of Model based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Model" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Model".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Model based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DslModeling::SerializationUtilities.UnescapeXmlString(reader.GetAttribute(this.MonikerAttributeName));
			if (monikerString == null)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, Model.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Model, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Model.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Model.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Model instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Model instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Model instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Model instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			writer.WriteAttributeString(this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Model instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Model instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Model instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			Model instanceOfModel = element as Model;
			global::System.Diagnostics.Debug.Assert(instanceOfModel != null, "Expecting an instance of Model");
	
			// UseNullables
			if (!serializationContext.Result.Failed)
			{
				NullableUsage propValue = instanceOfModel.UseNullables;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NullableUsage>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "No") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("useNullables", serializedPropValue);
					}
				}
			}
			// CaseOfPrivateFields
			if (!serializationContext.Result.Failed)
			{
				FieldCase propValue = instanceOfModel.CaseOfPrivateFields;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<FieldCase>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "CamelcaseUnderscore") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("caseOfPrivateFields", serializedPropValue);
					}
				}
			}
			// GenerateMonoRailProject
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.GenerateMonoRailProject;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("generateMonoRailProject", serializedPropValue);
					}
				}
			}
			// MonoRailProjectName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.MonoRailProjectName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("monoRailProjectName", propValue);
				}
			}
			// MonoRailProjectPath
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.MonoRailProjectPath;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("monoRailProjectPath", propValue);
				}
			}
			// MonoRailDefaultLayout
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.MonoRailDefaultLayout;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "default") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("monoRailDefaultLayout", propValue);
					}
				}
			}
			// MonoRailDefaultRescue
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.MonoRailDefaultRescue;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "generalerror") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("monoRailDefaultRescue", propValue);
					}
				}
			}
			// MonoRailViewFileExtension
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.MonoRailViewFileExtension;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, ".vm") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("monoRailViewFileExtension", propValue);
					}
				}
			}
			// UseGenerics
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.UseGenerics;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("useGenerics", serializedPropValue);
					}
				}
			}
			// UseBaseClass
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.UseBaseClass;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("useBaseClass", serializedPropValue);
					}
				}
			}
			// BaseClassName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.BaseClassName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("baseClassName", propValue);
				}
			}
			// GeneratesDoubleDerived
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.GeneratesDoubleDerived;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("generatesDoubleDerived", serializedPropValue);
					}
				}
			}
			// DoubleDerivedNameSuffix
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.DoubleDerivedNameSuffix;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "Base") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("doubleDerivedNameSuffix", propValue);
					}
				}
			}
			// UseGeneratedCodeAttribute
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.UseGeneratedCodeAttribute;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("useGeneratedCodeAttribute", serializedPropValue);
					}
				}
			}
			// Target
			if (!serializationContext.Result.Failed)
			{
				CodeGenerationTarget propValue = instanceOfModel.Target;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CodeGenerationTarget>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "ActiveRecord") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("target", serializedPropValue);
					}
				}
			}
			// AssemblyPath
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.AssemblyPath;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("assemblyPath", propValue);
				}
			}
			// ActiveRecordAssemblyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.ActiveRecordAssemblyName;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "Castle.ActiveRecord") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("activeRecordAssemblyName", propValue);
					}
				}
			}
			// NHibernateAssemblyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.NHibernateAssemblyName;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "NHibernate") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("nHibernateAssemblyName", propValue);
					}
				}
			}
			// RelateWithActiwFile
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.RelateWithActiwFile;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("relateWithActiwFile", serializedPropValue);
					}
				}
			}
			// UseVirtualProperties
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.UseVirtualProperties;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("useVirtualProperties", serializedPropValue);
					}
				}
			}
			// Namespace
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModel.Namespace;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("namespace", propValue);
				}
			}
			// ImplementINotifyPropertyChanged
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModel.ImplementINotifyPropertyChanged;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("implementINotifyPropertyChanged", serializedPropValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Model instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			Model instance = element as Model;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Model!");
	
			// Write properties serialized as nested XML elements.
			if (!serializationContext.Result.Failed)
				WritePropertiesAsElements(serializationContext, instance, writer);
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
	
		/// <summary>
		/// Serialize all properties that need to be stored as nested XML elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Model instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]	
		private static void WritePropertiesAsElements(DslModeling::SerializationContext serializationContext, Model element, global::System.Xml.XmlWriter writer)
		{
			// AdditionalImports
			if (!serializationContext.Result.Failed)
			{
				global::System.Collections.Generic.List<Altinoren.ActiveWriter.Import> propValue = element.AdditionalImports;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Collections.Generic.List<Altinoren.ActiveWriter.Import>>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					writer.WriteElementString("additionalImports", serializedPropValue);
				}
			}
		} 
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Model instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, Model element, global::System.Xml.XmlWriter writer)
		{
			// ModelHasClass
			global::System.Collections.ObjectModel.ReadOnlyCollection<ModelHasClass> allModelHasClassInstances = ModelHasClass.GetLinksToClasses(element);
			if (!serializationContext.Result.Failed && allModelHasClassInstances.Count > 0)
			{
				writer.WriteStartElement("classes");
				global::System.Type typeofModelHasClass = typeof(ModelHasClass);
				foreach (ModelHasClass eachModelHasClassInstance in allModelHasClassInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachModelHasClassInstance.GetType() != typeofModelHasClass)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachModelHasClassInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachModelHasClassInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachModelHasClassInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachModelHasClassInstance.Class;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
			// ModelHasNestedClasses
			global::System.Collections.ObjectModel.ReadOnlyCollection<ModelHasNestedClasses> allModelHasNestedClassesInstances = ModelHasNestedClasses.GetLinksToNestedClasses(element);
			if (!serializationContext.Result.Failed && allModelHasNestedClassesInstances.Count > 0)
			{
				writer.WriteStartElement("nestedClasses");
				global::System.Type typeofModelHasNestedClasses = typeof(ModelHasNestedClasses);
				foreach (ModelHasNestedClasses eachModelHasNestedClassesInstance in allModelHasNestedClassesInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachModelHasNestedClassesInstance.GetType() != typeofModelHasNestedClasses)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachModelHasNestedClassesInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachModelHasNestedClassesInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachModelHasNestedClassesInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachModelHasNestedClassesInstance.NestedClass;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Model instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Model instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Model instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Model instance = element as Model;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Model!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Model instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer ModelClassSerializer for DomainClass ModelClass.
	/// </summary>
	public partial class ModelClassSerializer : ModelElementWithAccessSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelClassSerializer Constructor
		/// </summary>
		public ModelClassSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ModelClass.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelClass"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ModelClass.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelClassMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ModelClass in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ModelClass instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelClass element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ModelClass instanceOfModelClass = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instanceOfModelClass != null, "Expecting an instance of ModelClass");
	
			// Cache
			if (!serializationContext.Result.Failed)
			{
				string attribCache = reader.GetAttribute("cache");
				if (attribCache != null)
				{
					CacheEnum valueOfCache;
					if (DslModeling::SerializationUtilities.TryGetValue<CacheEnum>(DslModeling::SerializationUtilities.UnescapeXmlString(attribCache), out valueOfCache))
					{
						instanceOfModelClass.Cache = valueOfCache;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "cache", typeof(CacheEnum), attribCache);
					}
				}
			}
			// DiscriminatorColumn
			if (!serializationContext.Result.Failed)
			{
				string attribDiscriminatorColumn = reader.GetAttribute("discriminatorColumn");
				if (attribDiscriminatorColumn != null)
				{
					global::System.String valueOfDiscriminatorColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDiscriminatorColumn), out valueOfDiscriminatorColumn))
					{
						instanceOfModelClass.DiscriminatorColumn = valueOfDiscriminatorColumn;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "discriminatorColumn", typeof(global::System.String), attribDiscriminatorColumn);
					}
				}
			}
			// DiscriminatorType
			if (!serializationContext.Result.Failed)
			{
				string attribDiscriminatorType = reader.GetAttribute("discriminatorType");
				if (attribDiscriminatorType != null)
				{
					global::System.String valueOfDiscriminatorType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDiscriminatorType), out valueOfDiscriminatorType))
					{
						instanceOfModelClass.DiscriminatorType = valueOfDiscriminatorType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "discriminatorType", typeof(global::System.String), attribDiscriminatorType);
					}
				}
			}
			// DiscriminatorValue
			if (!serializationContext.Result.Failed)
			{
				string attribDiscriminatorValue = reader.GetAttribute("discriminatorValue");
				if (attribDiscriminatorValue != null)
				{
					global::System.String valueOfDiscriminatorValue;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDiscriminatorValue), out valueOfDiscriminatorValue))
					{
						instanceOfModelClass.DiscriminatorValue = valueOfDiscriminatorValue;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "discriminatorValue", typeof(global::System.String), attribDiscriminatorValue);
					}
				}
			}
			// Lazy
			if (!serializationContext.Result.Failed)
			{
				string attribLazy = reader.GetAttribute("lazy");
				if (attribLazy != null)
				{
					global::System.Boolean valueOfLazy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribLazy), out valueOfLazy))
					{
						instanceOfModelClass.Lazy = valueOfLazy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "lazy", typeof(global::System.Boolean), attribLazy);
					}
				}
			}
			// Proxy
			if (!serializationContext.Result.Failed)
			{
				string attribProxy = reader.GetAttribute("proxy");
				if (attribProxy != null)
				{
					global::System.String valueOfProxy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribProxy), out valueOfProxy))
					{
						instanceOfModelClass.Proxy = valueOfProxy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "proxy", typeof(global::System.String), attribProxy);
					}
				}
			}
			// Schema
			if (!serializationContext.Result.Failed)
			{
				string attribSchema = reader.GetAttribute("schema");
				if (attribSchema != null)
				{
					global::System.String valueOfSchema;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSchema), out valueOfSchema))
					{
						instanceOfModelClass.Schema = valueOfSchema;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "schema", typeof(global::System.String), attribSchema);
					}
				}
			}
			// Table
			if (!serializationContext.Result.Failed)
			{
				string attribTable = reader.GetAttribute("table");
				if (attribTable != null)
				{
					global::System.String valueOfTable;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTable), out valueOfTable))
					{
						instanceOfModelClass.Table = valueOfTable;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "table", typeof(global::System.String), attribTable);
					}
				}
			}
			// Where
			if (!serializationContext.Result.Failed)
			{
				string attribWhere = reader.GetAttribute("where");
				if (attribWhere != null)
				{
					global::System.String valueOfWhere;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribWhere), out valueOfWhere))
					{
						instanceOfModelClass.Where = valueOfWhere;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "where", typeof(global::System.String), attribWhere);
					}
				}
			}
			// DynamicInsert
			if (!serializationContext.Result.Failed)
			{
				string attribDynamicInsert = reader.GetAttribute("dynamicInsert");
				if (attribDynamicInsert != null)
				{
					global::System.Boolean valueOfDynamicInsert;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDynamicInsert), out valueOfDynamicInsert))
					{
						instanceOfModelClass.DynamicInsert = valueOfDynamicInsert;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "dynamicInsert", typeof(global::System.Boolean), attribDynamicInsert);
					}
				}
			}
			// DynamicUpdate
			if (!serializationContext.Result.Failed)
			{
				string attribDynamicUpdate = reader.GetAttribute("dynamicUpdate");
				if (attribDynamicUpdate != null)
				{
					global::System.Boolean valueOfDynamicUpdate;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDynamicUpdate), out valueOfDynamicUpdate))
					{
						instanceOfModelClass.DynamicUpdate = valueOfDynamicUpdate;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "dynamicUpdate", typeof(global::System.Boolean), attribDynamicUpdate);
					}
				}
			}
			// Persister
			if (!serializationContext.Result.Failed)
			{
				string attribPersister = reader.GetAttribute("persister");
				if (attribPersister != null)
				{
					global::System.String valueOfPersister;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribPersister), out valueOfPersister))
					{
						instanceOfModelClass.Persister = valueOfPersister;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "persister", typeof(global::System.String), attribPersister);
					}
				}
			}
			// SelectBeforeUpdate
			if (!serializationContext.Result.Failed)
			{
				string attribSelectBeforeUpdate = reader.GetAttribute("selectBeforeUpdate");
				if (attribSelectBeforeUpdate != null)
				{
					global::System.Boolean valueOfSelectBeforeUpdate;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSelectBeforeUpdate), out valueOfSelectBeforeUpdate))
					{
						instanceOfModelClass.SelectBeforeUpdate = valueOfSelectBeforeUpdate;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "selectBeforeUpdate", typeof(global::System.Boolean), attribSelectBeforeUpdate);
					}
				}
			}
			// Polymorphism
			if (!serializationContext.Result.Failed)
			{
				string attribPolymorphism = reader.GetAttribute("polymorphism");
				if (attribPolymorphism != null)
				{
					Polymorphism valueOfPolymorphism;
					if (DslModeling::SerializationUtilities.TryGetValue<Polymorphism>(DslModeling::SerializationUtilities.UnescapeXmlString(attribPolymorphism), out valueOfPolymorphism))
					{
						instanceOfModelClass.Polymorphism = valueOfPolymorphism;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "polymorphism", typeof(Polymorphism), attribPolymorphism);
					}
				}
			}
			// Mutable
			if (!serializationContext.Result.Failed)
			{
				string attribMutable = reader.GetAttribute("mutable");
				if (attribMutable != null)
				{
					global::System.Boolean valueOfMutable;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribMutable), out valueOfMutable))
					{
						instanceOfModelClass.Mutable = valueOfMutable;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "mutable", typeof(global::System.Boolean), attribMutable);
					}
				}
			}
			// BatchSize
			if (!serializationContext.Result.Failed)
			{
				string attribBatchSize = reader.GetAttribute("batchSize");
				if (attribBatchSize != null)
				{
					global::System.Int32 valueOfBatchSize;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Int32>(DslModeling::SerializationUtilities.UnescapeXmlString(attribBatchSize), out valueOfBatchSize))
					{
						instanceOfModelClass.BatchSize = valueOfBatchSize;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "batchSize", typeof(global::System.Int32), attribBatchSize);
					}
				}
			}
			// Locking
			if (!serializationContext.Result.Failed)
			{
				string attribLocking = reader.GetAttribute("locking");
				if (attribLocking != null)
				{
					OptimisticLocking valueOfLocking;
					if (DslModeling::SerializationUtilities.TryGetValue<OptimisticLocking>(DslModeling::SerializationUtilities.UnescapeXmlString(attribLocking), out valueOfLocking))
					{
						instanceOfModelClass.Locking = valueOfLocking;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "locking", typeof(OptimisticLocking), attribLocking);
					}
				}
			}
			// UseAutoImport
			if (!serializationContext.Result.Failed)
			{
				string attribUseAutoImport = reader.GetAttribute("useAutoImport");
				if (attribUseAutoImport != null)
				{
					global::System.Boolean valueOfUseAutoImport;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUseAutoImport), out valueOfUseAutoImport))
					{
						instanceOfModelClass.UseAutoImport = valueOfUseAutoImport;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useAutoImport", typeof(global::System.Boolean), attribUseAutoImport);
					}
				}
			}
			// BaseClassName
			if (!serializationContext.Result.Failed)
			{
				string attribBaseClassName = reader.GetAttribute("baseClassName");
				if (attribBaseClassName != null)
				{
					global::System.String valueOfBaseClassName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribBaseClassName), out valueOfBaseClassName))
					{
						instanceOfModelClass.BaseClassName = valueOfBaseClassName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "baseClassName", typeof(global::System.String), attribBaseClassName);
					}
				}
			}
			// UseGenerics
			if (!serializationContext.Result.Failed)
			{
				string attribUseGenerics = reader.GetAttribute("useGenerics");
				if (attribUseGenerics != null)
				{
					InheritableBoolean valueOfUseGenerics;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritableBoolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUseGenerics), out valueOfUseGenerics))
					{
						instanceOfModelClass.UseGenerics = valueOfUseGenerics;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useGenerics", typeof(InheritableBoolean), attribUseGenerics);
					}
				}
			}
			// ImplementINotifyPropertyChanged
			if (!serializationContext.Result.Failed)
			{
				string attribImplementINotifyPropertyChanged = reader.GetAttribute("implementINotifyPropertyChanged");
				if (attribImplementINotifyPropertyChanged != null)
				{
					InheritableBoolean valueOfImplementINotifyPropertyChanged;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritableBoolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribImplementINotifyPropertyChanged), out valueOfImplementINotifyPropertyChanged))
					{
						instanceOfModelClass.ImplementINotifyPropertyChanged = valueOfImplementINotifyPropertyChanged;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "implementINotifyPropertyChanged", typeof(InheritableBoolean), attribImplementINotifyPropertyChanged);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			base.ReadElements(serializationContext, element, reader);
	
			ModelClass instanceOfModelClass = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instanceOfModelClass != null, "Expecting an instance of ModelClass!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfModelClass, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
	        /// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies the if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "targets":	// Relationship "ManyToOneRelation"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <targets>
							ReadManyToOneRelationInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </targets>
						}
						break;
					case "properties":	// Relationship "ClassHasProperty"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <properties>
							ReadClassHasPropertyInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </properties>
						}
						break;
					case "manyToManyTargets":	// Relationship "ManyToManyRelation"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <manyToManyTargets>
							ReadManyToManyRelationInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </manyToManyTargets>
						}
						break;
					case "oneToOneTarget":	// Relationship "OneToOneRelation"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <oneToOneTarget>
							ReadOneToOneRelationInstance(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </oneToOneTarget>
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ManyToOneRelation.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadManyToOneRelationInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newManyToOneRelationSerializer = serializationContext.Directory.GetSerializer(ManyToOneRelation.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newManyToOneRelationSerializer != null, "Cannot find serializer for ManyToOneRelation!");
				ManyToOneRelation newManyToOneRelation = newManyToOneRelationSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ManyToOneRelation;
				if (newManyToOneRelation != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newManyToOneRelation, ManyToOneRelation.SourceDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newManyToOneRelation.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newManyToOneRelation.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newManyToOneRelation, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newModelClassMonikerOfManyToOneRelationSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfManyToOneRelationSerializer != null, "Cannot find serializer for ModelClass!");
					DslModeling::Moniker newModelClassMonikerOfManyToOneRelation = newModelClassMonikerOfManyToOneRelationSerializer.TryCreateMonikerInstance(serializationContext, reader, element, ManyToOneRelation.DomainClassId, element.Partition);
					if (newModelClassMonikerOfManyToOneRelation != null)
					{
						ActiveWriterSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(ManyToOneRelation));
						new ManyToOneRelation(element.Partition, new DslModeling::RoleAssignment(ManyToOneRelation.SourceDomainRoleId, element), new DslModeling::RoleAssignment(ManyToOneRelation.TargetDomainRoleId, newModelClassMonikerOfManyToOneRelation));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ClassHasProperty.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadClassHasPropertyInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newModelPropertyOfClassHasPropertySerializer = serializationContext.Directory.GetSerializer(ModelProperty.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newModelPropertyOfClassHasPropertySerializer != null, "Cannot find serializer for ModelProperty!");
				ModelProperty newModelPropertyOfClassHasProperty = newModelPropertyOfClassHasPropertySerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ModelProperty;
				if (newModelPropertyOfClassHasProperty != null)
				{
					element.Properties.Add(newModelPropertyOfClassHasProperty);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelPropertyOfClassHasProperty.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelPropertyOfClassHasProperty.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newModelPropertyOfClassHasProperty, reader);
				}
				else
				{
					global::System.Type typeofClassHasProperty = typeof(ClassHasProperty);
					DslModeling::DomainRelationshipXmlSerializer newClassHasPropertySerializer = serializationContext.Directory.GetSerializer(ClassHasProperty.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newClassHasPropertySerializer != null, "Cannot find serializer for ClassHasProperty!");
					ClassHasProperty newClassHasProperty = newClassHasPropertySerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ClassHasProperty;
					if (newClassHasProperty != null)
					{
						if (newClassHasProperty.GetType() == typeofClassHasProperty)
						{	// The relationship should be serialized in short-form.
							ActiveWriterSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(ClassHasProperty));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newClassHasProperty, ClassHasProperty.ModelClassDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newClassHasProperty.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newClassHasProperty.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newClassHasProperty, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship ManyToManyRelation.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadManyToManyRelationInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newManyToManyRelationSerializer = serializationContext.Directory.GetSerializer(ManyToManyRelation.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newManyToManyRelationSerializer != null, "Cannot find serializer for ManyToManyRelation!");
				ManyToManyRelation newManyToManyRelation = newManyToManyRelationSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ManyToManyRelation;
				if (newManyToManyRelation != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newManyToManyRelation, ManyToManyRelation.SourceDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newManyToManyRelation.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newManyToManyRelation.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newManyToManyRelation, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newModelClassMonikerOfManyToManyRelationSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfManyToManyRelationSerializer != null, "Cannot find serializer for ModelClass!");
					DslModeling::Moniker newModelClassMonikerOfManyToManyRelation = newModelClassMonikerOfManyToManyRelationSerializer.TryCreateMonikerInstance(serializationContext, reader, element, ManyToManyRelation.DomainClassId, element.Partition);
					if (newModelClassMonikerOfManyToManyRelation != null)
					{
						ActiveWriterSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(ManyToManyRelation));
						new ManyToManyRelation(element.Partition, new DslModeling::RoleAssignment(ManyToManyRelation.SourceDomainRoleId, element), new DslModeling::RoleAssignment(ManyToManyRelation.TargetDomainRoleId, newModelClassMonikerOfManyToManyRelation));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads instance of relationship OneToOneRelation.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize only the first valid instance and ignore all the
		/// rest tags (because the multiplicity allows only one instance). When the method returns, the reader will be positioned at 
		/// the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadOneToOneRelationInstance(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
		{
			if (DslModeling::DomainRoleInfo.GetElementLinks<OneToOneRelation> (element, OneToOneRelation.SourceDomainRoleId).Count > 0)
			{	// Only allow one instance, which already exists, so skip everything
				DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
				return;
			}
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newOneToOneRelationSerializer = serializationContext.Directory.GetSerializer(OneToOneRelation.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newOneToOneRelationSerializer != null, "Cannot find serializer for OneToOneRelation!");
				OneToOneRelation newOneToOneRelation = newOneToOneRelationSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as OneToOneRelation;
				if (newOneToOneRelation != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newOneToOneRelation, OneToOneRelation.SourceDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newOneToOneRelation.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newOneToOneRelation.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newOneToOneRelation, reader);
					break;	// Only allow one instance.
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newModelClassMonikerOfOneToOneRelationSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfOneToOneRelationSerializer != null, "Cannot find serializer for ModelClass!");
					DslModeling::Moniker newModelClassMonikerOfOneToOneRelation = newModelClassMonikerOfOneToOneRelationSerializer.TryCreateMonikerInstance(serializationContext, reader, element, OneToOneRelation.DomainClassId, element.Partition);
					if (newModelClassMonikerOfOneToOneRelation != null)
					{
						ActiveWriterSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(OneToOneRelation));
						new OneToOneRelation(element.Partition, new DslModeling::RoleAssignment(OneToOneRelation.SourceDomainRoleId, element), new DslModeling::RoleAssignment(OneToOneRelation.TargetDomainRoleId, newModelClassMonikerOfOneToOneRelation));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
						break;	// Only allow one instance.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ModelClass based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelClass, a new ModelClass instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelClass instance, or null if the reader is not pointing to a serialized ModelClass instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelClass" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ModelClass".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ModelClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelClassSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelClass based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelClass.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelClass instance should be created.</param>	
		/// <returns>Created ModelClass instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new ModelClass(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelClass, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelClass itself) instance of ModelClass based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelClass" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ModelClass".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelClassSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelClass based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DslModeling::SerializationUtilities.UnescapeXmlString(reader.GetAttribute(this.MonikerAttributeName));
			if (monikerString == null)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, ModelClass.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelClass, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelClass instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelClass instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelClass instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			writer.WriteAttributeString(this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelClass instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ModelClass instanceOfModelClass = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instanceOfModelClass != null, "Expecting an instance of ModelClass");
	
			// Cache
			if (!serializationContext.Result.Failed)
			{
				CacheEnum propValue = instanceOfModelClass.Cache;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CacheEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Undefined") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("cache", serializedPropValue);
					}
				}
			}
			// DiscriminatorColumn
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.DiscriminatorColumn;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("discriminatorColumn", propValue);
				}
			}
			// DiscriminatorType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.DiscriminatorType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("discriminatorType", propValue);
				}
			}
			// DiscriminatorValue
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.DiscriminatorValue;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("discriminatorValue", propValue);
				}
			}
			// Lazy
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelClass.Lazy;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("lazy", serializedPropValue);
					}
				}
			}
			// Proxy
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.Proxy;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("proxy", propValue);
				}
			}
			// Schema
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.Schema;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("schema", propValue);
				}
			}
			// Table
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.Table;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("table", propValue);
				}
			}
			// Where
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.Where;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("where", propValue);
				}
			}
			// DynamicInsert
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelClass.DynamicInsert;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("dynamicInsert", serializedPropValue);
					}
				}
			}
			// DynamicUpdate
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelClass.DynamicUpdate;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("dynamicUpdate", serializedPropValue);
					}
				}
			}
			// Persister
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.Persister;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("persister", propValue);
				}
			}
			// SelectBeforeUpdate
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelClass.SelectBeforeUpdate;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("selectBeforeUpdate", serializedPropValue);
					}
				}
			}
			// Polymorphism
			if (!serializationContext.Result.Failed)
			{
				Polymorphism propValue = instanceOfModelClass.Polymorphism;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<Polymorphism>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Implicit") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("polymorphism", serializedPropValue);
					}
				}
			}
			// Mutable
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelClass.Mutable;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("mutable", serializedPropValue);
					}
				}
			}
			// BatchSize
			if (!serializationContext.Result.Failed)
			{
				global::System.Int32 propValue = instanceOfModelClass.BatchSize;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Int32>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "1") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("batchSize", serializedPropValue);
					}
				}
			}
			// Locking
			if (!serializationContext.Result.Failed)
			{
				OptimisticLocking propValue = instanceOfModelClass.Locking;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<OptimisticLocking>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Version") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("locking", serializedPropValue);
					}
				}
			}
			// UseAutoImport
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelClass.UseAutoImport;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("useAutoImport", serializedPropValue);
					}
				}
			}
			// BaseClassName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelClass.BaseClassName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("baseClassName", propValue);
				}
			}
			// UseGenerics
			if (!serializationContext.Result.Failed)
			{
				InheritableBoolean propValue = instanceOfModelClass.UseGenerics;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritableBoolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("useGenerics", serializedPropValue);
					}
				}
			}
			// ImplementINotifyPropertyChanged
			if (!serializationContext.Result.Failed)
			{
				InheritableBoolean propValue = instanceOfModelClass.ImplementINotifyPropertyChanged;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritableBoolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("implementINotifyPropertyChanged", serializedPropValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			base.WriteElements(serializationContext, element, writer);
	
			ModelClass instance = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelClass!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlWriter writer)
		{
			// ManyToOneRelation
			global::System.Collections.ObjectModel.ReadOnlyCollection<ManyToOneRelation> allManyToOneRelationInstances = ManyToOneRelation.GetLinksToTargets(element);
			if (!serializationContext.Result.Failed && allManyToOneRelationInstances.Count > 0)
			{
				writer.WriteStartElement("targets");
				foreach (ManyToOneRelation eachManyToOneRelationInstance in allManyToOneRelationInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachManyToOneRelationInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachManyToOneRelationInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachManyToOneRelationInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// ClassHasProperty
			global::System.Collections.ObjectModel.ReadOnlyCollection<ClassHasProperty> allClassHasPropertyInstances = ClassHasProperty.GetLinksToProperties(element);
			if (!serializationContext.Result.Failed && allClassHasPropertyInstances.Count > 0)
			{
				writer.WriteStartElement("properties");
				global::System.Type typeofClassHasProperty = typeof(ClassHasProperty);
				foreach (ClassHasProperty eachClassHasPropertyInstance in allClassHasPropertyInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachClassHasPropertyInstance.GetType() != typeofClassHasProperty)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachClassHasPropertyInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachClassHasPropertyInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachClassHasPropertyInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachClassHasPropertyInstance.Property;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
			// ManyToManyRelation
			global::System.Collections.ObjectModel.ReadOnlyCollection<ManyToManyRelation> allManyToManyRelationInstances = ManyToManyRelation.GetLinksToManyToManyTargets(element);
			if (!serializationContext.Result.Failed && allManyToManyRelationInstances.Count > 0)
			{
				writer.WriteStartElement("manyToManyTargets");
				foreach (ManyToManyRelation eachManyToManyRelationInstance in allManyToManyRelationInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachManyToManyRelationInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachManyToManyRelationInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachManyToManyRelationInstance, writer);
				}
				writer.WriteEndElement();
			}
	
			// OneToOneRelation
			OneToOneRelation theOneToOneRelationInstance = OneToOneRelation.GetLinkToOneToOneTarget(element);
			if (!serializationContext.Result.Failed && theOneToOneRelationInstance != null)
			{
				writer.WriteStartElement("oneToOneTarget");
				DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(theOneToOneRelationInstance.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + theOneToOneRelationInstance.GetDomainClass().Name + "!");
				relSerializer.Write(serializationContext, theOneToOneRelationInstance, writer);
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelClass instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelClass instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelClass instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelClass instance = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelClass!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelClass instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelClass instance = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelClass!");
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer ModelPropertySerializer for DomainClass ModelProperty.
	/// </summary>
	public partial class ModelPropertySerializer : ModelElementWithAccessSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelPropertySerializer Constructor
		/// </summary>
		public ModelPropertySerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ModelProperty.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelProperty"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ModelProperty.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelPropertyMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ModelProperty in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ModelProperty instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelProperty element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelProperty instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelProperty instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ModelProperty instanceOfModelProperty = element as ModelProperty;
			global::System.Diagnostics.Debug.Assert(instanceOfModelProperty != null, "Expecting an instance of ModelProperty");
	
			// Column
			if (!serializationContext.Result.Failed)
			{
				string attribColumn = reader.GetAttribute("column");
				if (attribColumn != null)
				{
					global::System.String valueOfColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribColumn), out valueOfColumn))
					{
						instanceOfModelProperty.Column = valueOfColumn;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "column", typeof(global::System.String), attribColumn);
					}
				}
			}
			// ColumnType
			if (!serializationContext.Result.Failed)
			{
				string attribColumnType = reader.GetAttribute("columnType");
				if (attribColumnType != null)
				{
					NHibernateType valueOfColumnType;
					if (DslModeling::SerializationUtilities.TryGetValue<NHibernateType>(DslModeling::SerializationUtilities.UnescapeXmlString(attribColumnType), out valueOfColumnType))
					{
						instanceOfModelProperty.ColumnType = valueOfColumnType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "columnType", typeof(NHibernateType), attribColumnType);
					}
				}
			}
			// CustomColumnType
			if (!serializationContext.Result.Failed)
			{
				string attribCustomColumnType = reader.GetAttribute("customColumnType");
				if (attribCustomColumnType != null)
				{
					global::System.String valueOfCustomColumnType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribCustomColumnType), out valueOfCustomColumnType))
					{
						instanceOfModelProperty.CustomColumnType = valueOfCustomColumnType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "customColumnType", typeof(global::System.String), attribCustomColumnType);
					}
				}
			}
			// CustomMemberType
			if (!serializationContext.Result.Failed)
			{
				string attribCustomMemberType = reader.GetAttribute("customMemberType");
				if (attribCustomMemberType != null)
				{
					global::System.String valueOfCustomMemberType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribCustomMemberType), out valueOfCustomMemberType))
					{
						instanceOfModelProperty.CustomMemberType = valueOfCustomMemberType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "customMemberType", typeof(global::System.String), attribCustomMemberType);
					}
				}
			}
			// Formula
			if (!serializationContext.Result.Failed)
			{
				string attribFormula = reader.GetAttribute("formula");
				if (attribFormula != null)
				{
					global::System.String valueOfFormula;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribFormula), out valueOfFormula))
					{
						instanceOfModelProperty.Formula = valueOfFormula;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "formula", typeof(global::System.String), attribFormula);
					}
				}
			}
			// Insert
			if (!serializationContext.Result.Failed)
			{
				string attribInsert = reader.GetAttribute("insert");
				if (attribInsert != null)
				{
					global::System.Boolean valueOfInsert;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribInsert), out valueOfInsert))
					{
						instanceOfModelProperty.Insert = valueOfInsert;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "insert", typeof(global::System.Boolean), attribInsert);
					}
				}
			}
			// Length
			if (!serializationContext.Result.Failed)
			{
				string attribLength = reader.GetAttribute("length");
				if (attribLength != null)
				{
					global::System.Int32 valueOfLength;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Int32>(DslModeling::SerializationUtilities.UnescapeXmlString(attribLength), out valueOfLength))
					{
						instanceOfModelProperty.Length = valueOfLength;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "length", typeof(global::System.Int32), attribLength);
					}
				}
			}
			// NotNull
			if (!serializationContext.Result.Failed)
			{
				string attribNotNull = reader.GetAttribute("notNull");
				if (attribNotNull != null)
				{
					global::System.Boolean valueOfNotNull;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribNotNull), out valueOfNotNull))
					{
						instanceOfModelProperty.NotNull = valueOfNotNull;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "notNull", typeof(global::System.Boolean), attribNotNull);
					}
				}
			}
			// Unique
			if (!serializationContext.Result.Failed)
			{
				string attribUnique = reader.GetAttribute("unique");
				if (attribUnique != null)
				{
					global::System.Boolean valueOfUnique;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUnique), out valueOfUnique))
					{
						instanceOfModelProperty.Unique = valueOfUnique;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "unique", typeof(global::System.Boolean), attribUnique);
					}
				}
			}
			// UnsavedValue
			if (!serializationContext.Result.Failed)
			{
				string attribUnsavedValue = reader.GetAttribute("unsavedValue");
				if (attribUnsavedValue != null)
				{
					global::System.String valueOfUnsavedValue;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUnsavedValue), out valueOfUnsavedValue))
					{
						instanceOfModelProperty.UnsavedValue = valueOfUnsavedValue;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "unsavedValue", typeof(global::System.String), attribUnsavedValue);
					}
				}
			}
			// Update
			if (!serializationContext.Result.Failed)
			{
				string attribUpdate = reader.GetAttribute("update");
				if (attribUpdate != null)
				{
					global::System.Boolean valueOfUpdate;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUpdate), out valueOfUpdate))
					{
						instanceOfModelProperty.Update = valueOfUpdate;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "update", typeof(global::System.Boolean), attribUpdate);
					}
				}
			}
			// Generator
			if (!serializationContext.Result.Failed)
			{
				string attribGenerator = reader.GetAttribute("generator");
				if (attribGenerator != null)
				{
					PrimaryKeyType valueOfGenerator;
					if (DslModeling::SerializationUtilities.TryGetValue<PrimaryKeyType>(DslModeling::SerializationUtilities.UnescapeXmlString(attribGenerator), out valueOfGenerator))
					{
						instanceOfModelProperty.Generator = valueOfGenerator;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "generator", typeof(PrimaryKeyType), attribGenerator);
					}
				}
			}
			// KeyType
			if (!serializationContext.Result.Failed)
			{
				string attribKeyType = reader.GetAttribute("keyType");
				if (attribKeyType != null)
				{
					KeyType valueOfKeyType;
					if (DslModeling::SerializationUtilities.TryGetValue<KeyType>(DslModeling::SerializationUtilities.UnescapeXmlString(attribKeyType), out valueOfKeyType))
					{
						instanceOfModelProperty.KeyType = valueOfKeyType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "keyType", typeof(KeyType), attribKeyType);
					}
				}
			}
			// Params
			if (!serializationContext.Result.Failed)
			{
				string attribParams = reader.GetAttribute("params");
				if (attribParams != null)
				{
					global::System.String valueOfParams;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribParams), out valueOfParams))
					{
						instanceOfModelProperty.Params = valueOfParams;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "params", typeof(global::System.String), attribParams);
					}
				}
			}
			// SequenceName
			if (!serializationContext.Result.Failed)
			{
				string attribSequenceName = reader.GetAttribute("sequenceName");
				if (attribSequenceName != null)
				{
					global::System.String valueOfSequenceName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSequenceName), out valueOfSequenceName))
					{
						instanceOfModelProperty.SequenceName = valueOfSequenceName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sequenceName", typeof(global::System.String), attribSequenceName);
					}
				}
			}
			// Accessor
			if (!serializationContext.Result.Failed)
			{
				string attribAccessor = reader.GetAttribute("accessor");
				if (attribAccessor != null)
				{
					Accessor valueOfAccessor;
					if (DslModeling::SerializationUtilities.TryGetValue<Accessor>(DslModeling::SerializationUtilities.UnescapeXmlString(attribAccessor), out valueOfAccessor))
					{
						instanceOfModelProperty.Accessor = valueOfAccessor;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "accessor", typeof(Accessor), attribAccessor);
					}
				}
			}
			// CompositeKeyName
			if (!serializationContext.Result.Failed)
			{
				string attribCompositeKeyName = reader.GetAttribute("compositeKeyName");
				if (attribCompositeKeyName != null)
				{
					global::System.String valueOfCompositeKeyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribCompositeKeyName), out valueOfCompositeKeyName))
					{
						instanceOfModelProperty.CompositeKeyName = valueOfCompositeKeyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "compositeKeyName", typeof(global::System.String), attribCompositeKeyName);
					}
				}
			}
			// PropertyType
			if (!serializationContext.Result.Failed)
			{
				string attribPropertyType = reader.GetAttribute("propertyType");
				if (attribPropertyType != null)
				{
					PropertyType valueOfPropertyType;
					if (DslModeling::SerializationUtilities.TryGetValue<PropertyType>(DslModeling::SerializationUtilities.UnescapeXmlString(attribPropertyType), out valueOfPropertyType))
					{
						instanceOfModelProperty.PropertyType = valueOfPropertyType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "propertyType", typeof(PropertyType), attribPropertyType);
					}
				}
			}
			// DebuggerDisplay
			if (!serializationContext.Result.Failed)
			{
				string attribDebuggerDisplay = reader.GetAttribute("debuggerDisplay");
				if (attribDebuggerDisplay != null)
				{
					global::System.Boolean valueOfDebuggerDisplay;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDebuggerDisplay), out valueOfDebuggerDisplay))
					{
						instanceOfModelProperty.DebuggerDisplay = valueOfDebuggerDisplay;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "debuggerDisplay", typeof(global::System.Boolean), attribDebuggerDisplay);
					}
				}
			}
			// Validator
			if (!serializationContext.Result.Failed)
			{
				string attribValidator = reader.GetAttribute("validator");
				if (attribValidator != null)
				{
					global::System.String valueOfValidator;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribValidator), out valueOfValidator))
					{
						instanceOfModelProperty.Validator = valueOfValidator;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "validator", typeof(global::System.String), attribValidator);
					}
				}
			}
			// UniqueKey
			if (!serializationContext.Result.Failed)
			{
				string attribUniqueKey = reader.GetAttribute("uniqueKey");
				if (attribUniqueKey != null)
				{
					global::System.String valueOfUniqueKey;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUniqueKey), out valueOfUniqueKey))
					{
						instanceOfModelProperty.UniqueKey = valueOfUniqueKey;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "uniqueKey", typeof(global::System.String), attribUniqueKey);
					}
				}
			}
			// Index
			if (!serializationContext.Result.Failed)
			{
				string attribIndex = reader.GetAttribute("index");
				if (attribIndex != null)
				{
					global::System.String valueOfIndex;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribIndex), out valueOfIndex))
					{
						instanceOfModelProperty.Index = valueOfIndex;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "index", typeof(global::System.String), attribIndex);
					}
				}
			}
			// SqlType
			if (!serializationContext.Result.Failed)
			{
				string attribSqlType = reader.GetAttribute("sqlType");
				if (attribSqlType != null)
				{
					global::System.String valueOfSqlType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSqlType), out valueOfSqlType))
					{
						instanceOfModelProperty.SqlType = valueOfSqlType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sqlType", typeof(global::System.String), attribSqlType);
					}
				}
			}
			// Check
			if (!serializationContext.Result.Failed)
			{
				string attribCheck = reader.GetAttribute("check");
				if (attribCheck != null)
				{
					global::System.String valueOfCheck;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribCheck), out valueOfCheck))
					{
						instanceOfModelProperty.Check = valueOfCheck;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "check", typeof(global::System.String), attribCheck);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ModelProperty based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelProperty, a new ModelProperty instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelProperty instance, or null if the reader is not pointing to a serialized ModelProperty instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelProperty" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ModelProperty".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ModelPropertySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelPropertySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelProperty based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelProperty.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelProperty instance should be created.</param>	
		/// <returns>Created ModelProperty instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (idStr == null)
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					ActiveWriterSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new ModelProperty(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelProperty, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelProperty.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelProperty itself) instance of ModelProperty based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelProperty" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ModelProperty".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelPropertySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelPropertySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelProperty based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DslModeling::SerializationUtilities.UnescapeXmlString(reader.GetAttribute(this.MonikerAttributeName));
			if (monikerString == null)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, ModelProperty.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelProperty, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelProperty.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelProperty instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelProperty instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelProperty instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelProperty instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			writer.WriteAttributeString(this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelProperty instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelProperty instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelProperty instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ModelProperty instanceOfModelProperty = element as ModelProperty;
			global::System.Diagnostics.Debug.Assert(instanceOfModelProperty != null, "Expecting an instance of ModelProperty");
	
			// Column
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.Column;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("column", propValue);
				}
			}
			// ColumnType
			if (!serializationContext.Result.Failed)
			{
				NHibernateType propValue = instanceOfModelProperty.ColumnType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NHibernateType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "String") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("columnType", serializedPropValue);
					}
				}
			}
			// CustomColumnType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.CustomColumnType;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("customColumnType", propValue);
					}
				}
			}
			// CustomMemberType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.CustomMemberType;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("customMemberType", propValue);
					}
				}
			}
			// Formula
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.Formula;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("formula", propValue);
				}
			}
			// Insert
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelProperty.Insert;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("insert", serializedPropValue);
					}
				}
			}
			// Length
			if (!serializationContext.Result.Failed)
			{
				global::System.Int32 propValue = instanceOfModelProperty.Length;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Int32>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					writer.WriteAttributeString("length", serializedPropValue);
				}
			}
			// NotNull
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelProperty.NotNull;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("notNull", serializedPropValue);
					}
				}
			}
			// Unique
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelProperty.Unique;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("unique", serializedPropValue);
					}
				}
			}
			// UnsavedValue
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.UnsavedValue;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("unsavedValue", propValue);
				}
			}
			// Update
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelProperty.Update;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("update", serializedPropValue);
					}
				}
			}
			// Generator
			if (!serializationContext.Result.Failed)
			{
				PrimaryKeyType propValue = instanceOfModelProperty.Generator;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<PrimaryKeyType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Native") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("generator", serializedPropValue);
					}
				}
			}
			// KeyType
			if (!serializationContext.Result.Failed)
			{
				KeyType propValue = instanceOfModelProperty.KeyType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<KeyType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("keyType", serializedPropValue);
					}
				}
			}
			// Params
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.Params;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("params", propValue);
				}
			}
			// SequenceName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.SequenceName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sequenceName", propValue);
				}
			}
			// Accessor
			if (!serializationContext.Result.Failed)
			{
				Accessor propValue = instanceOfModelProperty.Accessor;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<Accessor>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Public") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("accessor", serializedPropValue);
					}
				}
			}
			// CompositeKeyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.CompositeKeyName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("compositeKeyName", propValue);
				}
			}
			// PropertyType
			if (!serializationContext.Result.Failed)
			{
				PropertyType propValue = instanceOfModelProperty.PropertyType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<PropertyType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Property") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("propertyType", serializedPropValue);
					}
				}
			}
			// DebuggerDisplay
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfModelProperty.DebuggerDisplay;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("debuggerDisplay", serializedPropValue);
					}
				}
			}
			// Validator
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.Validator;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null)
						writer.WriteAttributeString("validator", propValue);
				}
			}
			// UniqueKey
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.UniqueKey;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("uniqueKey", propValue);
				}
			}
			// Index
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.Index;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("index", propValue);
				}
			}
			// SqlType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.SqlType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sqlType", propValue);
				}
			}
			// Check
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelProperty.Check;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("check", propValue);
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelProperty instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelProperty instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelProperty instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelProperty instance = element as ModelProperty;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelProperty!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelProperty instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelProperty instance = element as ModelProperty;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelProperty!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer ModelElementWithAccessSerializer for DomainClass ModelElementWithAccess.
	/// </summary>
	public partial class ModelElementWithAccessSerializer : NamedElementSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelElementWithAccessSerializer Constructor
		/// </summary>
		public ModelElementWithAccessSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// Cannot be serialized.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// ModelElementWithAccess is abstract and cannot be instantiated, so this method throws NotSupportedException.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelElementWithAccess element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelElementWithAccess instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelElementWithAccess instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			ModelElementWithAccess instanceOfModelElementWithAccess = element as ModelElementWithAccess;
			global::System.Diagnostics.Debug.Assert(instanceOfModelElementWithAccess != null, "Expecting an instance of ModelElementWithAccess");
	
			// CustomAccess
			if (!serializationContext.Result.Failed)
			{
				string attribCustomAccess = reader.GetAttribute("customAccess");
				if (attribCustomAccess != null)
				{
					global::System.String valueOfCustomAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribCustomAccess), out valueOfCustomAccess))
					{
						instanceOfModelElementWithAccess.CustomAccess = valueOfCustomAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "customAccess", typeof(global::System.String), attribCustomAccess);
					}
				}
			}
			// Access
			if (!serializationContext.Result.Failed)
			{
				string attribAccess = reader.GetAttribute("access");
				if (attribAccess != null)
				{
					PropertyAccess valueOfAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<PropertyAccess>(DslModeling::SerializationUtilities.UnescapeXmlString(attribAccess), out valueOfAccess))
					{
						instanceOfModelElementWithAccess.Access = valueOfAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "access", typeof(PropertyAccess), attribAccess);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ModelElementWithAccess based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelElementWithAccess, a new ModelElementWithAccess instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelElementWithAccess instance, or null if the reader is not pointing to a serialized ModelElementWithAccess instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "ModelElementWithAccess".
				if (this.derivedClasses == null)
					this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class instance.
					ModelElementWithAccessSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelElementWithAccessSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelElementWithAccess based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelElementWithAccess.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelElementWithAccess instance should be created.</param>	
		/// <returns>Created ModelElementWithAccess instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Abstract class, cannot be serialized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelElementWithAccess, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelElementWithAccess.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelElementWithAccess.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelElementWithAccess itself) instance of ModelElementWithAccess based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "ModelElementWithAccess".
				if (this.derivedClassMonikers == null)
					this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class moniker instance.
					ModelElementWithAccessSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelElementWithAccessSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelElementWithAccess based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DslModeling::SerializationUtilities.UnescapeXmlString(reader.GetAttribute(this.MonikerAttributeName));
			if (monikerString == null)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, ModelElementWithAccess.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelElementWithAccess, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelElementWithAccess.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelElementWithAccess.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelElementWithAccess instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelElementWithAccess instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelElementWithAccess instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelElementWithAccess instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ModelElementWithAccess cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ModelElementWithAccess");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelElementWithAccess instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelElementWithAccess instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelElementWithAccess instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			ModelElementWithAccess instanceOfModelElementWithAccess = element as ModelElementWithAccess;
			global::System.Diagnostics.Debug.Assert(instanceOfModelElementWithAccess != null, "Expecting an instance of ModelElementWithAccess");
	
			// CustomAccess
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfModelElementWithAccess.CustomAccess;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("customAccess", propValue);
				}
			}
			// Access
			if (!serializationContext.Result.Failed)
			{
				PropertyAccess propValue = instanceOfModelElementWithAccess.Access;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<PropertyAccess>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Property") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("access", serializedPropValue);
					}
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelElementWithAccess instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelElementWithAccess instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelElementWithAccess instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelElementWithAccess instance = element as ModelElementWithAccess;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelElementWithAccess!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelElementWithAccess instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelElementWithAccess instance = element as ModelElementWithAccess;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelElementWithAccess!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer NamedElementSerializer for DomainClass NamedElement.
	/// </summary>
	public partial class NamedElementSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// NamedElementSerializer Constructor
		/// </summary>
		public NamedElementSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// Cannot be serialized.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// NamedElement is abstract and cannot be instantiated, so this method throws NotSupportedException.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the NamedElement element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NamedElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NamedElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			NamedElement instanceOfNamedElement = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instanceOfNamedElement != null, "Expecting an instance of NamedElement");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				string attribName = reader.GetAttribute("name");
				if (attribName != null)
				{
					global::System.String valueOfName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribName), out valueOfName))
					{
						instanceOfNamedElement.Name = valueOfName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
					}
				}
			}
			// Description
			if (!serializationContext.Result.Failed)
			{
				string attribDescription = reader.GetAttribute("description");
				if (attribDescription != null)
				{
					global::System.String valueOfDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDescription), out valueOfDescription))
					{
						instanceOfNamedElement.Description = valueOfDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "description", typeof(global::System.String), attribDescription);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NamedElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of NamedElement based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized NamedElement, a new NamedElement instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created NamedElement instance, or null if the reader is not pointing to a serialized NamedElement instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "NamedElement".
				if (this.derivedClasses == null)
					this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class instance.
					NamedElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NamedElementSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of NamedElement based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of NamedElement.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new NamedElement instance should be created.</param>	
		/// <returns>Created NamedElement instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Abstract class, cannot be serialized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from NamedElement, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from NamedElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NamedElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including NamedElement itself) instance of NamedElement based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "NamedElement".
				if (this.derivedClassMonikers == null)
					this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class moniker instance.
					NamedElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NamedElementSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of NamedElement based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DslModeling::SerializationUtilities.UnescapeXmlString(reader.GetAttribute(this.MonikerAttributeName));
			if (monikerString == null)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, NamedElement.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from NamedElement, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from NamedElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NamedElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized NamedElement instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NamedElement instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the NamedElement instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the NamedElement instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of NamedElement cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "NamedElement");
		}
		
		/// <summary>
		/// Public Write() method that serializes one NamedElement instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NamedElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NamedElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			NamedElement instanceOfNamedElement = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instanceOfNamedElement != null, "Expecting an instance of NamedElement");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfNamedElement.Name;
				if (!serializationContext.Result.Failed)
				{
					writer.WriteAttributeString("name", propValue);
				}
			}
			// Description
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfNamedElement.Description;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("description", propValue);
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NamedElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given NamedElement instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NamedElement instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the NamedElement instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NamedElement instance = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NamedElement!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NamedElement instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NamedElement instance = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NamedElement!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer NestedClassSerializer for DomainClass NestedClass.
	/// </summary>
	public partial class NestedClassSerializer : NamedElementSerializer
	{
		#region Constructor
		/// <summary>
		/// NestedClassSerializer Constructor
		/// </summary>
		public NestedClassSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of NestedClass.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nestedClass"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of NestedClass.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nestedClassMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of NestedClass in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one NestedClass instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the NestedClass element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			NestedClass instanceOfNestedClass = element as NestedClass;
			global::System.Diagnostics.Debug.Assert(instanceOfNestedClass != null, "Expecting an instance of NestedClass");
	
			// ImplementINotifyPropertyChanged
			if (!serializationContext.Result.Failed)
			{
				string attribImplementINotifyPropertyChanged = reader.GetAttribute("implementINotifyPropertyChanged");
				if (attribImplementINotifyPropertyChanged != null)
				{
					InheritableBoolean valueOfImplementINotifyPropertyChanged;
					if (DslModeling::SerializationUtilities.TryGetValue<InheritableBoolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribImplementINotifyPropertyChanged), out valueOfImplementINotifyPropertyChanged))
					{
						instanceOfNestedClass.ImplementINotifyPropertyChanged = valueOfImplementINotifyPropertyChanged;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "implementINotifyPropertyChanged", typeof(InheritableBoolean), attribImplementINotifyPropertyChanged);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			base.ReadElements(serializationContext, element, reader);
	
			NestedClass instanceOfNestedClass = element as NestedClass;
			global::System.Diagnostics.Debug.Assert(instanceOfNestedClass != null, "Expecting an instance of NestedClass!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfNestedClass, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
	        /// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies the if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory NestedClass instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, NestedClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				switch (reader.LocalName)
				{
					case "properties":	// Relationship "NestedClassHasProperties"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <properties>
							ReadNestedClassHasPropertiesInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </properties>
						}
						break;
					case "modelClasses":	// Relationship "NestedClassReferencesModelClasses"
						if (reader.IsEmptyElement)
						{	// No instance of this relationship, just skip
							DslModeling::SerializationUtilities.Skip(reader);
						}
						else
						{
							DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <modelClasses>
							ReadNestedClassReferencesModelClassesInstances(serializationContext, element, reader);
							DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </modelClasses>
						}
						break;
					default:
						return;  // Don't know this element.
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship NestedClassHasProperties.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadNestedClassHasPropertiesInstances(DslModeling::SerializationContext serializationContext, NestedClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newModelPropertyOfNestedClassHasPropertiesSerializer = serializationContext.Directory.GetSerializer(ModelProperty.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newModelPropertyOfNestedClassHasPropertiesSerializer != null, "Cannot find serializer for ModelProperty!");
				ModelProperty newModelPropertyOfNestedClassHasProperties = newModelPropertyOfNestedClassHasPropertiesSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ModelProperty;
				if (newModelPropertyOfNestedClassHasProperties != null)
				{
					element.Properties.Add(newModelPropertyOfNestedClassHasProperties);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelPropertyOfNestedClassHasProperties.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelPropertyOfNestedClassHasProperties.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newModelPropertyOfNestedClassHasProperties, reader);
				}
				else
				{
					global::System.Type typeofNestedClassHasProperties = typeof(NestedClassHasProperties);
					DslModeling::DomainRelationshipXmlSerializer newNestedClassHasPropertiesSerializer = serializationContext.Directory.GetSerializer(NestedClassHasProperties.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(newNestedClassHasPropertiesSerializer != null, "Cannot find serializer for NestedClassHasProperties!");
					NestedClassHasProperties newNestedClassHasProperties = newNestedClassHasPropertiesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as NestedClassHasProperties;
					if (newNestedClassHasProperties != null)
					{
						if (newNestedClassHasProperties.GetType() == typeofNestedClassHasProperties)
						{	// The relationship should be serialized in short-form.
							ActiveWriterSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(NestedClassHasProperties));
						}
						DslModeling::DomainRoleInfo.SetRolePlayer (newNestedClassHasProperties, NestedClassHasProperties.NestedClassDomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newNestedClassHasProperties.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newNestedClassHasProperties.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newNestedClassHasProperties, reader);
					}
					else
					{	// Unknown element, skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship NestedClassReferencesModelClasses.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadNestedClassReferencesModelClassesInstances(DslModeling::SerializationContext serializationContext, NestedClass element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newNestedClassReferencesModelClassesSerializer = serializationContext.Directory.GetSerializer(NestedClassReferencesModelClasses.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newNestedClassReferencesModelClassesSerializer != null, "Cannot find serializer for NestedClassReferencesModelClasses!");
				NestedClassReferencesModelClasses newNestedClassReferencesModelClasses = newNestedClassReferencesModelClassesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as NestedClassReferencesModelClasses;
				if (newNestedClassReferencesModelClasses != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newNestedClassReferencesModelClasses, NestedClassReferencesModelClasses.NestedClassDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newNestedClassReferencesModelClasses.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newNestedClassReferencesModelClasses.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newNestedClassReferencesModelClasses, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newModelClassMonikerOfNestedClassReferencesModelClassesSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfNestedClassReferencesModelClassesSerializer != null, "Cannot find serializer for ModelClass!");
					DslModeling::Moniker newModelClassMonikerOfNestedClassReferencesModelClasses = newModelClassMonikerOfNestedClassReferencesModelClassesSerializer.TryCreateMonikerInstance(serializationContext, reader, element, NestedClassReferencesModelClasses.DomainClassId, element.Partition);
					if (newModelClassMonikerOfNestedClassReferencesModelClasses != null)
					{
						ActiveWriterSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(NestedClassReferencesModelClasses));
						new NestedClassReferencesModelClasses(element.Partition, new DslModeling::RoleAssignment(NestedClassReferencesModelClasses.NestedClassDomainRoleId, element), new DslModeling::RoleAssignment(NestedClassReferencesModelClasses.ModelClassDomainRoleId, newModelClassMonikerOfNestedClassReferencesModelClasses));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of NestedClass based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized NestedClass, a new NestedClass instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created NestedClass instance, or null if the reader is not pointing to a serialized NestedClass instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClass" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "NestedClass".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						NestedClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of NestedClass based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of NestedClass.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new NestedClass instance should be created.</param>	
		/// <returns>Created NestedClass instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new NestedClass(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from NestedClass, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from NestedClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including NestedClass itself) instance of NestedClass based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClass" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "NestedClass".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						NestedClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of NestedClass based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DslModeling::SerializationUtilities.UnescapeXmlString(reader.GetAttribute(this.MonikerAttributeName));
			if (monikerString == null)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, NestedClass.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClass, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized NestedClass instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClass instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the NestedClass instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the NestedClass instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			writer.WriteAttributeString(this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one NestedClass instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			NestedClass instanceOfNestedClass = element as NestedClass;
			global::System.Diagnostics.Debug.Assert(instanceOfNestedClass != null, "Expecting an instance of NestedClass");
	
			// ImplementINotifyPropertyChanged
			if (!serializationContext.Result.Failed)
			{
				InheritableBoolean propValue = instanceOfNestedClass.ImplementINotifyPropertyChanged;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<InheritableBoolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Inherit") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("implementINotifyPropertyChanged", serializedPropValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			base.WriteElements(serializationContext, element, writer);
	
			NestedClass instance = element as NestedClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClass!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, NestedClass element, global::System.Xml.XmlWriter writer)
		{
			// NestedClassHasProperties
			global::System.Collections.ObjectModel.ReadOnlyCollection<NestedClassHasProperties> allNestedClassHasPropertiesInstances = NestedClassHasProperties.GetLinksToProperties(element);
			if (!serializationContext.Result.Failed && allNestedClassHasPropertiesInstances.Count > 0)
			{
				writer.WriteStartElement("properties");
				global::System.Type typeofNestedClassHasProperties = typeof(NestedClassHasProperties);
				foreach (NestedClassHasProperties eachNestedClassHasPropertiesInstance in allNestedClassHasPropertiesInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					if (eachNestedClassHasPropertiesInstance.GetType() != typeofNestedClassHasProperties)
					{	// Derived relationships will be serialized in full-form.
						DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachNestedClassHasPropertiesInstance.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachNestedClassHasPropertiesInstance.GetDomainClass().Name + "!");			
						derivedRelSerializer.Write(serializationContext, eachNestedClassHasPropertiesInstance, writer);
					}
					else
					{	// No need to serialize the relationship itself, just serialize the role-player directly.
						DslModeling::ModelElement targetElement = eachNestedClassHasPropertiesInstance.Property;
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
						global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
						targetSerializer.Write(serializationContext, targetElement, writer);
					}
				}
				writer.WriteEndElement();
			}
	
			// NestedClassReferencesModelClasses
			global::System.Collections.ObjectModel.ReadOnlyCollection<NestedClassReferencesModelClasses> allNestedClassReferencesModelClassesInstances = NestedClassReferencesModelClasses.GetLinksToModelClasses(element);
			if (!serializationContext.Result.Failed && allNestedClassReferencesModelClassesInstances.Count > 0)
			{
				writer.WriteStartElement("modelClasses");
				foreach (NestedClassReferencesModelClasses eachNestedClassReferencesModelClassesInstance in allNestedClassReferencesModelClassesInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachNestedClassReferencesModelClassesInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachNestedClassReferencesModelClassesInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachNestedClassReferencesModelClassesInstance, writer);
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given NestedClass instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClass instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the NestedClass instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedClass instance = element as NestedClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClass!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClass instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedClass instance = element as NestedClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClass!");
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer ModelHasClassSerializer for DomainClass ModelHasClass.
	/// </summary>
	public partial class ModelHasClassSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelHasClassSerializer Constructor
		/// </summary>
		public ModelHasClassSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ModelHasClass.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelHasClass"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ModelHasClass instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelHasClass element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Class
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player Class.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelHasClass");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player Class.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasClass instance that will link to the target ModelClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Class
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ModelHasClass.ClassDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelHasClass");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasClass instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ModelHasClass based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelHasClass, a new ModelHasClass instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelHasClass instance, or null if the reader is not pointing to a serialized ModelHasClass instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ModelHasClass based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ModelHasClass type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ModelHasClass, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelHasClass" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ModelHasClass".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ModelHasClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelHasClassSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelHasClass based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelHasClass.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelHasClass instance should be created.</param>	
		/// <returns>Created ModelHasClass instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new ModelHasClass(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelHasClass.ModelDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelHasClass.ClassDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelHasClass, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelHasClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelHasClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelHasClass itself) instance of ModelHasClass based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelHasClass" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ModelHasClass".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelHasClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelHasClassSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelHasClass based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelHasClass, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelHasClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelHasClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelHasClass instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasClass instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelHasClass instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelHasClass instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ModelHasClass cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ModelHasClass");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelHasClass instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasClass instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelHasClass instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelHasClass instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelHasClass instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelHasClass instance = element as ModelHasClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelHasClass!");
	
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelHasClass instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelHasClass instance = element as ModelHasClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelHasClass!");
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer ManyToOneRelationSerializer for DomainClass ManyToOneRelation.
	/// </summary>
	public partial class ManyToOneRelationSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ManyToOneRelationSerializer Constructor
		/// </summary>
		public ManyToOneRelationSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ManyToOneRelation.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToOneRelation"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ManyToOneRelation.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToOneRelationMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ManyToOneRelation in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ManyToOneRelation instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ManyToOneRelation element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToOneRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements, which include at least the monikerized instance of target role-player Target
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player Target.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ManyToOneRelation");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player Target.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToOneRelation instance that will link to the target ModelClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player Target
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((ManyToOneRelation)element).Source, ManyToOneRelation.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, ManyToOneRelation.TargetDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ManyToOneRelation");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToOneRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			ManyToOneRelation instanceOfManyToOneRelation = element as ManyToOneRelation;
			global::System.Diagnostics.Debug.Assert(instanceOfManyToOneRelation != null, "Expecting an instance of ManyToOneRelation");
	
			// TargetCache
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCache = reader.GetAttribute("targetCache");
				if (attribTargetCache != null)
				{
					CacheEnum valueOfTargetCache;
					if (DslModeling::SerializationUtilities.TryGetValue<CacheEnum>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetCache), out valueOfTargetCache))
					{
						instanceOfManyToOneRelation.TargetCache = valueOfTargetCache;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCache", typeof(CacheEnum), attribTargetCache);
					}
				}
			}
			// TargetCascade
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCascade = reader.GetAttribute("targetCascade");
				if (attribTargetCascade != null)
				{
					ManyRelationCascadeEnum valueOfTargetCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<ManyRelationCascadeEnum>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetCascade), out valueOfTargetCascade))
					{
						instanceOfManyToOneRelation.TargetCascade = valueOfTargetCascade;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCascade", typeof(ManyRelationCascadeEnum), attribTargetCascade);
					}
				}
			}
			// TargetColumnKey
			if (!serializationContext.Result.Failed)
			{
				string attribTargetColumnKey = reader.GetAttribute("targetColumnKey");
				if (attribTargetColumnKey != null)
				{
					global::System.String valueOfTargetColumnKey;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetColumnKey), out valueOfTargetColumnKey))
					{
						instanceOfManyToOneRelation.TargetColumnKey = valueOfTargetColumnKey;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetColumnKey", typeof(global::System.String), attribTargetColumnKey);
					}
				}
			}
			// TargetCustomAccess
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCustomAccess = reader.GetAttribute("targetCustomAccess");
				if (attribTargetCustomAccess != null)
				{
					global::System.String valueOfTargetCustomAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetCustomAccess), out valueOfTargetCustomAccess))
					{
						instanceOfManyToOneRelation.TargetCustomAccess = valueOfTargetCustomAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCustomAccess", typeof(global::System.String), attribTargetCustomAccess);
					}
				}
			}
			// TargetInverse
			if (!serializationContext.Result.Failed)
			{
				string attribTargetInverse = reader.GetAttribute("targetInverse");
				if (attribTargetInverse != null)
				{
					global::System.Boolean valueOfTargetInverse;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetInverse), out valueOfTargetInverse))
					{
						instanceOfManyToOneRelation.TargetInverse = valueOfTargetInverse;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetInverse", typeof(global::System.Boolean), attribTargetInverse);
					}
				}
			}
			// TargetLazy
			if (!serializationContext.Result.Failed)
			{
				string attribTargetLazy = reader.GetAttribute("targetLazy");
				if (attribTargetLazy != null)
				{
					global::System.Boolean valueOfTargetLazy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetLazy), out valueOfTargetLazy))
					{
						instanceOfManyToOneRelation.TargetLazy = valueOfTargetLazy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetLazy", typeof(global::System.Boolean), attribTargetLazy);
					}
				}
			}
			// TargetMapType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetMapType = reader.GetAttribute("targetMapType");
				if (attribTargetMapType != null)
				{
					global::System.String valueOfTargetMapType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetMapType), out valueOfTargetMapType))
					{
						instanceOfManyToOneRelation.TargetMapType = valueOfTargetMapType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetMapType", typeof(global::System.String), attribTargetMapType);
					}
				}
			}
			// TargetOrderBy
			if (!serializationContext.Result.Failed)
			{
				string attribTargetOrderBy = reader.GetAttribute("targetOrderBy");
				if (attribTargetOrderBy != null)
				{
					global::System.String valueOfTargetOrderBy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetOrderBy), out valueOfTargetOrderBy))
					{
						instanceOfManyToOneRelation.TargetOrderBy = valueOfTargetOrderBy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetOrderBy", typeof(global::System.String), attribTargetOrderBy);
					}
				}
			}
			// TargetRelationType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetRelationType = reader.GetAttribute("targetRelationType");
				if (attribTargetRelationType != null)
				{
					RelationType valueOfTargetRelationType;
					if (DslModeling::SerializationUtilities.TryGetValue<RelationType>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetRelationType), out valueOfTargetRelationType))
					{
						instanceOfManyToOneRelation.TargetRelationType = valueOfTargetRelationType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetRelationType", typeof(RelationType), attribTargetRelationType);
					}
				}
			}
			// TargetSchema
			if (!serializationContext.Result.Failed)
			{
				string attribTargetSchema = reader.GetAttribute("targetSchema");
				if (attribTargetSchema != null)
				{
					global::System.String valueOfTargetSchema;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetSchema), out valueOfTargetSchema))
					{
						instanceOfManyToOneRelation.TargetSchema = valueOfTargetSchema;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetSchema", typeof(global::System.String), attribTargetSchema);
					}
				}
			}
			// TargetSort
			if (!serializationContext.Result.Failed)
			{
				string attribTargetSort = reader.GetAttribute("targetSort");
				if (attribTargetSort != null)
				{
					global::System.String valueOfTargetSort;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetSort), out valueOfTargetSort))
					{
						instanceOfManyToOneRelation.TargetSort = valueOfTargetSort;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetSort", typeof(global::System.String), attribTargetSort);
					}
				}
			}
			// TargetTable
			if (!serializationContext.Result.Failed)
			{
				string attribTargetTable = reader.GetAttribute("targetTable");
				if (attribTargetTable != null)
				{
					global::System.String valueOfTargetTable;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetTable), out valueOfTargetTable))
					{
						instanceOfManyToOneRelation.TargetTable = valueOfTargetTable;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetTable", typeof(global::System.String), attribTargetTable);
					}
				}
			}
			// TargetWhere
			if (!serializationContext.Result.Failed)
			{
				string attribTargetWhere = reader.GetAttribute("targetWhere");
				if (attribTargetWhere != null)
				{
					global::System.String valueOfTargetWhere;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetWhere), out valueOfTargetWhere))
					{
						instanceOfManyToOneRelation.TargetWhere = valueOfTargetWhere;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetWhere", typeof(global::System.String), attribTargetWhere);
					}
				}
			}
			// TargetDescription
			if (!serializationContext.Result.Failed)
			{
				string attribTargetDescription = reader.GetAttribute("targetDescription");
				if (attribTargetDescription != null)
				{
					global::System.String valueOfTargetDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetDescription), out valueOfTargetDescription))
					{
						instanceOfManyToOneRelation.TargetDescription = valueOfTargetDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetDescription", typeof(global::System.String), attribTargetDescription);
					}
				}
			}
			// TargetPropertyName
			if (!serializationContext.Result.Failed)
			{
				string attribTargetPropertyName = reader.GetAttribute("targetPropertyName");
				if (attribTargetPropertyName != null)
				{
					global::System.String valueOfTargetPropertyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetPropertyName), out valueOfTargetPropertyName))
					{
						instanceOfManyToOneRelation.TargetPropertyName = valueOfTargetPropertyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetPropertyName", typeof(global::System.String), attribTargetPropertyName);
					}
				}
			}
			// TargetPropertyType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetPropertyType = reader.GetAttribute("targetPropertyType");
				if (attribTargetPropertyType != null)
				{
					global::System.String valueOfTargetPropertyType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetPropertyType), out valueOfTargetPropertyType))
					{
						instanceOfManyToOneRelation.TargetPropertyType = valueOfTargetPropertyType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetPropertyType", typeof(global::System.String), attribTargetPropertyType);
					}
				}
			}
			// SourceCascade
			if (!serializationContext.Result.Failed)
			{
				string attribSourceCascade = reader.GetAttribute("sourceCascade");
				if (attribSourceCascade != null)
				{
					CascadeEnum valueOfSourceCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<CascadeEnum>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceCascade), out valueOfSourceCascade))
					{
						instanceOfManyToOneRelation.SourceCascade = valueOfSourceCascade;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCascade", typeof(CascadeEnum), attribSourceCascade);
					}
				}
			}
			// SourceColumn
			if (!serializationContext.Result.Failed)
			{
				string attribSourceColumn = reader.GetAttribute("sourceColumn");
				if (attribSourceColumn != null)
				{
					global::System.String valueOfSourceColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceColumn), out valueOfSourceColumn))
					{
						instanceOfManyToOneRelation.SourceColumn = valueOfSourceColumn;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceColumn", typeof(global::System.String), attribSourceColumn);
					}
				}
			}
			// SourceCustomAccess
			if (!serializationContext.Result.Failed)
			{
				string attribSourceCustomAccess = reader.GetAttribute("sourceCustomAccess");
				if (attribSourceCustomAccess != null)
				{
					global::System.String valueOfSourceCustomAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceCustomAccess), out valueOfSourceCustomAccess))
					{
						instanceOfManyToOneRelation.SourceCustomAccess = valueOfSourceCustomAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCustomAccess", typeof(global::System.String), attribSourceCustomAccess);
					}
				}
			}
			// SourceInsert
			if (!serializationContext.Result.Failed)
			{
				string attribSourceInsert = reader.GetAttribute("sourceInsert");
				if (attribSourceInsert != null)
				{
					global::System.Boolean valueOfSourceInsert;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceInsert), out valueOfSourceInsert))
					{
						instanceOfManyToOneRelation.SourceInsert = valueOfSourceInsert;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceInsert", typeof(global::System.Boolean), attribSourceInsert);
					}
				}
			}
			// SourceNotNull
			if (!serializationContext.Result.Failed)
			{
				string attribSourceNotNull = reader.GetAttribute("sourceNotNull");
				if (attribSourceNotNull != null)
				{
					global::System.Boolean valueOfSourceNotNull;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceNotNull), out valueOfSourceNotNull))
					{
						instanceOfManyToOneRelation.SourceNotNull = valueOfSourceNotNull;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceNotNull", typeof(global::System.Boolean), attribSourceNotNull);
					}
				}
			}
			// SourceOuterJoin
			if (!serializationContext.Result.Failed)
			{
				string attribSourceOuterJoin = reader.GetAttribute("sourceOuterJoin");
				if (attribSourceOuterJoin != null)
				{
					OuterJoinEnum valueOfSourceOuterJoin;
					if (DslModeling::SerializationUtilities.TryGetValue<OuterJoinEnum>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceOuterJoin), out valueOfSourceOuterJoin))
					{
						instanceOfManyToOneRelation.SourceOuterJoin = valueOfSourceOuterJoin;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceOuterJoin", typeof(OuterJoinEnum), attribSourceOuterJoin);
					}
				}
			}
			// SourceType
			if (!serializationContext.Result.Failed)
			{
				string attribSourceType = reader.GetAttribute("sourceType");
				if (attribSourceType != null)
				{
					global::System.String valueOfSourceType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceType), out valueOfSourceType))
					{
						instanceOfManyToOneRelation.SourceType = valueOfSourceType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceType", typeof(global::System.String), attribSourceType);
					}
				}
			}
			// SourceUnique
			if (!serializationContext.Result.Failed)
			{
				string attribSourceUnique = reader.GetAttribute("sourceUnique");
				if (attribSourceUnique != null)
				{
					global::System.Boolean valueOfSourceUnique;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceUnique), out valueOfSourceUnique))
					{
						instanceOfManyToOneRelation.SourceUnique = valueOfSourceUnique;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceUnique", typeof(global::System.Boolean), attribSourceUnique);
					}
				}
			}
			// SourceUpdate
			if (!serializationContext.Result.Failed)
			{
				string attribSourceUpdate = reader.GetAttribute("sourceUpdate");
				if (attribSourceUpdate != null)
				{
					global::System.Boolean valueOfSourceUpdate;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceUpdate), out valueOfSourceUpdate))
					{
						instanceOfManyToOneRelation.SourceUpdate = valueOfSourceUpdate;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceUpdate", typeof(global::System.Boolean), attribSourceUpdate);
					}
				}
			}
			// SourceDescription
			if (!serializationContext.Result.Failed)
			{
				string attribSourceDescription = reader.GetAttribute("sourceDescription");
				if (attribSourceDescription != null)
				{
					global::System.String valueOfSourceDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceDescription), out valueOfSourceDescription))
					{
						instanceOfManyToOneRelation.SourceDescription = valueOfSourceDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceDescription", typeof(global::System.String), attribSourceDescription);
					}
				}
			}
			// TargetAccess
			if (!serializationContext.Result.Failed)
			{
				string attribTargetAccess = reader.GetAttribute("targetAccess");
				if (attribTargetAccess != null)
				{
					PropertyAccess valueOfTargetAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<PropertyAccess>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetAccess), out valueOfTargetAccess))
					{
						instanceOfManyToOneRelation.TargetAccess = valueOfTargetAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetAccess", typeof(PropertyAccess), attribTargetAccess);
					}
				}
			}
			// SourcePropertyName
			if (!serializationContext.Result.Failed)
			{
				string attribSourcePropertyName = reader.GetAttribute("sourcePropertyName");
				if (attribSourcePropertyName != null)
				{
					global::System.String valueOfSourcePropertyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourcePropertyName), out valueOfSourcePropertyName))
					{
						instanceOfManyToOneRelation.SourcePropertyName = valueOfSourcePropertyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourcePropertyName", typeof(global::System.String), attribSourcePropertyName);
					}
				}
			}
			// SourceNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				string attribSourceNotFoundBehaviour = reader.GetAttribute("sourceNotFoundBehaviour");
				if (attribSourceNotFoundBehaviour != null)
				{
					NotFoundBehaviour valueOfSourceNotFoundBehaviour;
					if (DslModeling::SerializationUtilities.TryGetValue<NotFoundBehaviour>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceNotFoundBehaviour), out valueOfSourceNotFoundBehaviour))
					{
						instanceOfManyToOneRelation.SourceNotFoundBehaviour = valueOfSourceNotFoundBehaviour;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceNotFoundBehaviour", typeof(NotFoundBehaviour), attribSourceNotFoundBehaviour);
					}
				}
			}
			// TargetNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				string attribTargetNotFoundBehaviour = reader.GetAttribute("targetNotFoundBehaviour");
				if (attribTargetNotFoundBehaviour != null)
				{
					NotFoundBehaviour valueOfTargetNotFoundBehaviour;
					if (DslModeling::SerializationUtilities.TryGetValue<NotFoundBehaviour>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetNotFoundBehaviour), out valueOfTargetNotFoundBehaviour))
					{
						instanceOfManyToOneRelation.TargetNotFoundBehaviour = valueOfTargetNotFoundBehaviour;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetNotFoundBehaviour", typeof(NotFoundBehaviour), attribTargetNotFoundBehaviour);
					}
				}
			}
			// TargetElement
			if (!serializationContext.Result.Failed)
			{
				string attribTargetElement = reader.GetAttribute("targetElement");
				if (attribTargetElement != null)
				{
					global::System.String valueOfTargetElement;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetElement), out valueOfTargetElement))
					{
						instanceOfManyToOneRelation.TargetElement = valueOfTargetElement;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetElement", typeof(global::System.String), attribTargetElement);
					}
				}
			}
			// TargetIndexType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetIndexType = reader.GetAttribute("targetIndexType");
				if (attribTargetIndexType != null)
				{
					global::System.String valueOfTargetIndexType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetIndexType), out valueOfTargetIndexType))
					{
						instanceOfManyToOneRelation.TargetIndexType = valueOfTargetIndexType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetIndexType", typeof(global::System.String), attribTargetIndexType);
					}
				}
			}
			// TargetIndex
			if (!serializationContext.Result.Failed)
			{
				string attribTargetIndex = reader.GetAttribute("targetIndex");
				if (attribTargetIndex != null)
				{
					global::System.String valueOfTargetIndex;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetIndex), out valueOfTargetIndex))
					{
						instanceOfManyToOneRelation.TargetIndex = valueOfTargetIndex;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetIndex", typeof(global::System.String), attribTargetIndex);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToOneRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ManyToOneRelation based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ManyToOneRelation, a new ManyToOneRelation instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ManyToOneRelation instance, or null if the reader is not pointing to a serialized ManyToOneRelation instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ManyToOneRelation based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ManyToOneRelation type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ManyToOneRelation, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToOneRelation" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ManyToOneRelation".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ManyToOneRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToOneRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ManyToOneRelation based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ManyToOneRelation.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ManyToOneRelation instance should be created.</param>	
		/// <returns>Created ManyToOneRelation instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (idStr == null)
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					ActiveWriterSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new ManyToOneRelation(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ManyToOneRelation.SourceDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ManyToOneRelation.TargetDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ManyToOneRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ManyToOneRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToOneRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ManyToOneRelation itself) instance of ManyToOneRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToOneRelation" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ManyToOneRelation".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ManyToOneRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToOneRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ManyToOneRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DslModeling::SerializationUtilities.UnescapeXmlString(reader.GetAttribute(this.MonikerAttributeName));
			if (monikerString == null)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ManyToOneRelation.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToOneRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToOneRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToOneRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ManyToOneRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToOneRelation instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ManyToOneRelation instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ManyToOneRelation instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			writer.WriteAttributeString(this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ManyToOneRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToOneRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write the target role-player instance.
			ManyToOneRelation instance = element as ManyToOneRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToOneRelation!");
	
			DslModeling::ModelElement targetElement = instance.Target;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.Source, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToOneRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			ManyToOneRelation instanceOfManyToOneRelation = element as ManyToOneRelation;
			global::System.Diagnostics.Debug.Assert(instanceOfManyToOneRelation != null, "Expecting an instance of ManyToOneRelation");
	
			// TargetCache
			if (!serializationContext.Result.Failed)
			{
				CacheEnum propValue = instanceOfManyToOneRelation.TargetCache;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CacheEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Undefined") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetCache", serializedPropValue);
					}
				}
			}
			// TargetCascade
			if (!serializationContext.Result.Failed)
			{
				ManyRelationCascadeEnum propValue = instanceOfManyToOneRelation.TargetCascade;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<ManyRelationCascadeEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetCascade", serializedPropValue);
					}
				}
			}
			// TargetColumnKey
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetColumnKey;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetColumnKey", propValue);
				}
			}
			// TargetCustomAccess
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetCustomAccess;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetCustomAccess", propValue);
				}
			}
			// TargetInverse
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToOneRelation.TargetInverse;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetInverse", serializedPropValue);
					}
				}
			}
			// TargetLazy
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToOneRelation.TargetLazy;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetLazy", serializedPropValue);
					}
				}
			}
			// TargetMapType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetMapType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetMapType", propValue);
				}
			}
			// TargetOrderBy
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetOrderBy;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetOrderBy", propValue);
				}
			}
			// TargetRelationType
			if (!serializationContext.Result.Failed)
			{
				RelationType propValue = instanceOfManyToOneRelation.TargetRelationType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<RelationType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Guess") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetRelationType", serializedPropValue);
					}
				}
			}
			// TargetSchema
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetSchema;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetSchema", propValue);
				}
			}
			// TargetSort
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetSort;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetSort", propValue);
				}
			}
			// TargetTable
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetTable;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetTable", propValue);
				}
			}
			// TargetWhere
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetWhere;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetWhere", propValue);
				}
			}
			// TargetDescription
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetDescription;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetDescription", propValue);
				}
			}
			// TargetPropertyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetPropertyName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetPropertyName", propValue);
				}
			}
			// TargetPropertyType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetPropertyType;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "IList") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetPropertyType", propValue);
					}
				}
			}
			// SourceCascade
			if (!serializationContext.Result.Failed)
			{
				CascadeEnum propValue = instanceOfManyToOneRelation.SourceCascade;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CascadeEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceCascade", serializedPropValue);
					}
				}
			}
			// SourceColumn
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.SourceColumn;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourceColumn", propValue);
				}
			}
			// SourceCustomAccess
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.SourceCustomAccess;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourceCustomAccess", propValue);
				}
			}
			// SourceInsert
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToOneRelation.SourceInsert;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceInsert", serializedPropValue);
					}
				}
			}
			// SourceNotNull
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToOneRelation.SourceNotNull;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceNotNull", serializedPropValue);
					}
				}
			}
			// SourceOuterJoin
			if (!serializationContext.Result.Failed)
			{
				OuterJoinEnum propValue = instanceOfManyToOneRelation.SourceOuterJoin;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<OuterJoinEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Auto") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceOuterJoin", serializedPropValue);
					}
				}
			}
			// SourceType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.SourceType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourceType", propValue);
				}
			}
			// SourceUnique
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToOneRelation.SourceUnique;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceUnique", serializedPropValue);
					}
				}
			}
			// SourceUpdate
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToOneRelation.SourceUpdate;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceUpdate", serializedPropValue);
					}
				}
			}
			// SourceDescription
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.SourceDescription;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourceDescription", propValue);
				}
			}
			// TargetAccess
			if (!serializationContext.Result.Failed)
			{
				PropertyAccess propValue = instanceOfManyToOneRelation.TargetAccess;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<PropertyAccess>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Property") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetAccess", serializedPropValue);
					}
				}
			}
			// SourcePropertyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.SourcePropertyName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourcePropertyName", propValue);
				}
			}
			// SourceNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				NotFoundBehaviour propValue = instanceOfManyToOneRelation.SourceNotFoundBehaviour;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NotFoundBehaviour>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Default") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceNotFoundBehaviour", serializedPropValue);
					}
				}
			}
			// TargetNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				NotFoundBehaviour propValue = instanceOfManyToOneRelation.TargetNotFoundBehaviour;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NotFoundBehaviour>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Default") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetNotFoundBehaviour", serializedPropValue);
					}
				}
			}
			// TargetElement
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetElement;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetElement", propValue);
				}
			}
			// TargetIndexType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetIndexType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetIndexType", propValue);
				}
			}
			// TargetIndex
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToOneRelation.TargetIndex;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetIndex", propValue);
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToOneRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ManyToOneRelation instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToOneRelation instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ManyToOneRelation instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToOneRelation instance = element as ManyToOneRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToOneRelation!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToOneRelation instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, ManyToOneRelation.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), ManyToOneRelation.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer ClassHasPropertySerializer for DomainClass ClassHasProperty.
	/// </summary>
	public partial class ClassHasPropertySerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ClassHasPropertySerializer Constructor
		/// </summary>
		public ClassHasPropertySerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ClassHasProperty.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"classHasProperty"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ClassHasProperty instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ClassHasProperty element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasProperty instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Property
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player Property.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ClassHasProperty");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player Property.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasProperty instance that will link to the target ModelProperty instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Property
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelProperty!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ClassHasProperty.PropertyDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ClassHasProperty");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasProperty instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassHasProperty instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ClassHasProperty based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ClassHasProperty, a new ClassHasProperty instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ClassHasProperty instance, or null if the reader is not pointing to a serialized ClassHasProperty instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ClassHasProperty based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ClassHasProperty type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ClassHasProperty, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassHasProperty" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ClassHasProperty".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ClassHasPropertySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassHasPropertySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ClassHasProperty based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ClassHasProperty.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ClassHasProperty instance should be created.</param>	
		/// <returns>Created ClassHasProperty instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new ClassHasProperty(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ClassHasProperty.ModelClassDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ClassHasProperty.PropertyDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ClassHasProperty, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ClassHasProperty.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassHasProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ClassHasProperty itself) instance of ClassHasProperty based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassHasProperty" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ClassHasProperty".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ClassHasPropertySerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassHasPropertySerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ClassHasProperty based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassHasProperty, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassHasProperty.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassHasProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ClassHasProperty instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasProperty instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ClassHasProperty instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ClassHasProperty instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ClassHasProperty cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ClassHasProperty");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ClassHasProperty instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasProperty instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasProperty instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassHasProperty instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ClassHasProperty instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassHasProperty instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ClassHasProperty instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassHasProperty instance = element as ClassHasProperty;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassHasProperty!");
	
			DslModeling::ModelElement container = instance.ModelClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassHasProperty instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassHasProperty instance = element as ClassHasProperty;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassHasProperty!");
			DslModeling::ModelElement container = instance.ModelClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer ManyToManyRelationSerializer for DomainClass ManyToManyRelation.
	/// </summary>
	public partial class ManyToManyRelationSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ManyToManyRelationSerializer Constructor
		/// </summary>
		public ManyToManyRelationSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ManyToManyRelation.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToManyRelation"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ManyToManyRelation.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToManyRelationMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ManyToManyRelation in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ManyToManyRelation instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ManyToManyRelation element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToManyRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements, which include at least the monikerized instance of target role-player Target
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player Target.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ManyToManyRelation");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player Target.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToManyRelation instance that will link to the target ModelClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player Target
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((ManyToManyRelation)element).Source, ManyToManyRelation.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, ManyToManyRelation.TargetDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ManyToManyRelation");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToManyRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			ManyToManyRelation instanceOfManyToManyRelation = element as ManyToManyRelation;
			global::System.Diagnostics.Debug.Assert(instanceOfManyToManyRelation != null, "Expecting an instance of ManyToManyRelation");
	
			// SourceCache
			if (!serializationContext.Result.Failed)
			{
				string attribSourceCache = reader.GetAttribute("sourceCache");
				if (attribSourceCache != null)
				{
					CacheEnum valueOfSourceCache;
					if (DslModeling::SerializationUtilities.TryGetValue<CacheEnum>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceCache), out valueOfSourceCache))
					{
						instanceOfManyToManyRelation.SourceCache = valueOfSourceCache;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCache", typeof(CacheEnum), attribSourceCache);
					}
				}
			}
			// SourceCascade
			if (!serializationContext.Result.Failed)
			{
				string attribSourceCascade = reader.GetAttribute("sourceCascade");
				if (attribSourceCascade != null)
				{
					ManyRelationCascadeEnum valueOfSourceCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<ManyRelationCascadeEnum>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceCascade), out valueOfSourceCascade))
					{
						instanceOfManyToManyRelation.SourceCascade = valueOfSourceCascade;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCascade", typeof(ManyRelationCascadeEnum), attribSourceCascade);
					}
				}
			}
			// SourceColumn
			if (!serializationContext.Result.Failed)
			{
				string attribSourceColumn = reader.GetAttribute("sourceColumn");
				if (attribSourceColumn != null)
				{
					global::System.String valueOfSourceColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceColumn), out valueOfSourceColumn))
					{
						instanceOfManyToManyRelation.SourceColumn = valueOfSourceColumn;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceColumn", typeof(global::System.String), attribSourceColumn);
					}
				}
			}
			// SourceCustomAccess
			if (!serializationContext.Result.Failed)
			{
				string attribSourceCustomAccess = reader.GetAttribute("sourceCustomAccess");
				if (attribSourceCustomAccess != null)
				{
					global::System.String valueOfSourceCustomAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceCustomAccess), out valueOfSourceCustomAccess))
					{
						instanceOfManyToManyRelation.SourceCustomAccess = valueOfSourceCustomAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCustomAccess", typeof(global::System.String), attribSourceCustomAccess);
					}
				}
			}
			// SourceInverse
			if (!serializationContext.Result.Failed)
			{
				string attribSourceInverse = reader.GetAttribute("sourceInverse");
				if (attribSourceInverse != null)
				{
					global::System.Boolean valueOfSourceInverse;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceInverse), out valueOfSourceInverse))
					{
						instanceOfManyToManyRelation.SourceInverse = valueOfSourceInverse;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceInverse", typeof(global::System.Boolean), attribSourceInverse);
					}
				}
			}
			// SourceLazy
			if (!serializationContext.Result.Failed)
			{
				string attribSourceLazy = reader.GetAttribute("sourceLazy");
				if (attribSourceLazy != null)
				{
					global::System.Boolean valueOfSourceLazy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceLazy), out valueOfSourceLazy))
					{
						instanceOfManyToManyRelation.SourceLazy = valueOfSourceLazy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceLazy", typeof(global::System.Boolean), attribSourceLazy);
					}
				}
			}
			// SourceMapType
			if (!serializationContext.Result.Failed)
			{
				string attribSourceMapType = reader.GetAttribute("sourceMapType");
				if (attribSourceMapType != null)
				{
					global::System.String valueOfSourceMapType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceMapType), out valueOfSourceMapType))
					{
						instanceOfManyToManyRelation.SourceMapType = valueOfSourceMapType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceMapType", typeof(global::System.String), attribSourceMapType);
					}
				}
			}
			// SourceOrderBy
			if (!serializationContext.Result.Failed)
			{
				string attribSourceOrderBy = reader.GetAttribute("sourceOrderBy");
				if (attribSourceOrderBy != null)
				{
					global::System.String valueOfSourceOrderBy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceOrderBy), out valueOfSourceOrderBy))
					{
						instanceOfManyToManyRelation.SourceOrderBy = valueOfSourceOrderBy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceOrderBy", typeof(global::System.String), attribSourceOrderBy);
					}
				}
			}
			// SourceRelationType
			if (!serializationContext.Result.Failed)
			{
				string attribSourceRelationType = reader.GetAttribute("sourceRelationType");
				if (attribSourceRelationType != null)
				{
					RelationType valueOfSourceRelationType;
					if (DslModeling::SerializationUtilities.TryGetValue<RelationType>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceRelationType), out valueOfSourceRelationType))
					{
						instanceOfManyToManyRelation.SourceRelationType = valueOfSourceRelationType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceRelationType", typeof(RelationType), attribSourceRelationType);
					}
				}
			}
			// Schema
			if (!serializationContext.Result.Failed)
			{
				string attribSchema = reader.GetAttribute("schema");
				if (attribSchema != null)
				{
					global::System.String valueOfSchema;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSchema), out valueOfSchema))
					{
						instanceOfManyToManyRelation.Schema = valueOfSchema;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "schema", typeof(global::System.String), attribSchema);
					}
				}
			}
			// SourceSort
			if (!serializationContext.Result.Failed)
			{
				string attribSourceSort = reader.GetAttribute("sourceSort");
				if (attribSourceSort != null)
				{
					global::System.String valueOfSourceSort;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceSort), out valueOfSourceSort))
					{
						instanceOfManyToManyRelation.SourceSort = valueOfSourceSort;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceSort", typeof(global::System.String), attribSourceSort);
					}
				}
			}
			// Table
			if (!serializationContext.Result.Failed)
			{
				string attribTable = reader.GetAttribute("table");
				if (attribTable != null)
				{
					global::System.String valueOfTable;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTable), out valueOfTable))
					{
						instanceOfManyToManyRelation.Table = valueOfTable;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "table", typeof(global::System.String), attribTable);
					}
				}
			}
			// SourceWhere
			if (!serializationContext.Result.Failed)
			{
				string attribSourceWhere = reader.GetAttribute("sourceWhere");
				if (attribSourceWhere != null)
				{
					global::System.String valueOfSourceWhere;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceWhere), out valueOfSourceWhere))
					{
						instanceOfManyToManyRelation.SourceWhere = valueOfSourceWhere;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceWhere", typeof(global::System.String), attribSourceWhere);
					}
				}
			}
			// TargetCache
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCache = reader.GetAttribute("targetCache");
				if (attribTargetCache != null)
				{
					CacheEnum valueOfTargetCache;
					if (DslModeling::SerializationUtilities.TryGetValue<CacheEnum>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetCache), out valueOfTargetCache))
					{
						instanceOfManyToManyRelation.TargetCache = valueOfTargetCache;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCache", typeof(CacheEnum), attribTargetCache);
					}
				}
			}
			// TargetCascade
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCascade = reader.GetAttribute("targetCascade");
				if (attribTargetCascade != null)
				{
					ManyRelationCascadeEnum valueOfTargetCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<ManyRelationCascadeEnum>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetCascade), out valueOfTargetCascade))
					{
						instanceOfManyToManyRelation.TargetCascade = valueOfTargetCascade;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCascade", typeof(ManyRelationCascadeEnum), attribTargetCascade);
					}
				}
			}
			// TargetColumn
			if (!serializationContext.Result.Failed)
			{
				string attribTargetColumn = reader.GetAttribute("targetColumn");
				if (attribTargetColumn != null)
				{
					global::System.String valueOfTargetColumn;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetColumn), out valueOfTargetColumn))
					{
						instanceOfManyToManyRelation.TargetColumn = valueOfTargetColumn;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetColumn", typeof(global::System.String), attribTargetColumn);
					}
				}
			}
			// TargetCustomAccess
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCustomAccess = reader.GetAttribute("targetCustomAccess");
				if (attribTargetCustomAccess != null)
				{
					global::System.String valueOfTargetCustomAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetCustomAccess), out valueOfTargetCustomAccess))
					{
						instanceOfManyToManyRelation.TargetCustomAccess = valueOfTargetCustomAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCustomAccess", typeof(global::System.String), attribTargetCustomAccess);
					}
				}
			}
			// TargetInverse
			if (!serializationContext.Result.Failed)
			{
				string attribTargetInverse = reader.GetAttribute("targetInverse");
				if (attribTargetInverse != null)
				{
					global::System.Boolean valueOfTargetInverse;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetInverse), out valueOfTargetInverse))
					{
						instanceOfManyToManyRelation.TargetInverse = valueOfTargetInverse;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetInverse", typeof(global::System.Boolean), attribTargetInverse);
					}
				}
			}
			// TargetLazy
			if (!serializationContext.Result.Failed)
			{
				string attribTargetLazy = reader.GetAttribute("targetLazy");
				if (attribTargetLazy != null)
				{
					global::System.Boolean valueOfTargetLazy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetLazy), out valueOfTargetLazy))
					{
						instanceOfManyToManyRelation.TargetLazy = valueOfTargetLazy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetLazy", typeof(global::System.Boolean), attribTargetLazy);
					}
				}
			}
			// TargetMapType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetMapType = reader.GetAttribute("targetMapType");
				if (attribTargetMapType != null)
				{
					global::System.String valueOfTargetMapType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetMapType), out valueOfTargetMapType))
					{
						instanceOfManyToManyRelation.TargetMapType = valueOfTargetMapType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetMapType", typeof(global::System.String), attribTargetMapType);
					}
				}
			}
			// TargetOrderBy
			if (!serializationContext.Result.Failed)
			{
				string attribTargetOrderBy = reader.GetAttribute("targetOrderBy");
				if (attribTargetOrderBy != null)
				{
					global::System.String valueOfTargetOrderBy;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetOrderBy), out valueOfTargetOrderBy))
					{
						instanceOfManyToManyRelation.TargetOrderBy = valueOfTargetOrderBy;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetOrderBy", typeof(global::System.String), attribTargetOrderBy);
					}
				}
			}
			// TargetRelationType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetRelationType = reader.GetAttribute("targetRelationType");
				if (attribTargetRelationType != null)
				{
					RelationType valueOfTargetRelationType;
					if (DslModeling::SerializationUtilities.TryGetValue<RelationType>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetRelationType), out valueOfTargetRelationType))
					{
						instanceOfManyToManyRelation.TargetRelationType = valueOfTargetRelationType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetRelationType", typeof(RelationType), attribTargetRelationType);
					}
				}
			}
			// TargetSort
			if (!serializationContext.Result.Failed)
			{
				string attribTargetSort = reader.GetAttribute("targetSort");
				if (attribTargetSort != null)
				{
					global::System.String valueOfTargetSort;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetSort), out valueOfTargetSort))
					{
						instanceOfManyToManyRelation.TargetSort = valueOfTargetSort;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetSort", typeof(global::System.String), attribTargetSort);
					}
				}
			}
			// TargetWhere
			if (!serializationContext.Result.Failed)
			{
				string attribTargetWhere = reader.GetAttribute("targetWhere");
				if (attribTargetWhere != null)
				{
					global::System.String valueOfTargetWhere;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetWhere), out valueOfTargetWhere))
					{
						instanceOfManyToManyRelation.TargetWhere = valueOfTargetWhere;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetWhere", typeof(global::System.String), attribTargetWhere);
					}
				}
			}
			// SourceDescription
			if (!serializationContext.Result.Failed)
			{
				string attribSourceDescription = reader.GetAttribute("sourceDescription");
				if (attribSourceDescription != null)
				{
					global::System.String valueOfSourceDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceDescription), out valueOfSourceDescription))
					{
						instanceOfManyToManyRelation.SourceDescription = valueOfSourceDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceDescription", typeof(global::System.String), attribSourceDescription);
					}
				}
			}
			// TargetDescription
			if (!serializationContext.Result.Failed)
			{
				string attribTargetDescription = reader.GetAttribute("targetDescription");
				if (attribTargetDescription != null)
				{
					global::System.String valueOfTargetDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetDescription), out valueOfTargetDescription))
					{
						instanceOfManyToManyRelation.TargetDescription = valueOfTargetDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetDescription", typeof(global::System.String), attribTargetDescription);
					}
				}
			}
			// SourceAccess
			if (!serializationContext.Result.Failed)
			{
				string attribSourceAccess = reader.GetAttribute("sourceAccess");
				if (attribSourceAccess != null)
				{
					PropertyAccess valueOfSourceAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<PropertyAccess>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceAccess), out valueOfSourceAccess))
					{
						instanceOfManyToManyRelation.SourceAccess = valueOfSourceAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceAccess", typeof(PropertyAccess), attribSourceAccess);
					}
				}
			}
			// TargetAccess
			if (!serializationContext.Result.Failed)
			{
				string attribTargetAccess = reader.GetAttribute("targetAccess");
				if (attribTargetAccess != null)
				{
					PropertyAccess valueOfTargetAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<PropertyAccess>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetAccess), out valueOfTargetAccess))
					{
						instanceOfManyToManyRelation.TargetAccess = valueOfTargetAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetAccess", typeof(PropertyAccess), attribTargetAccess);
					}
				}
			}
			// SourcePropertyType
			if (!serializationContext.Result.Failed)
			{
				string attribSourcePropertyType = reader.GetAttribute("sourcePropertyType");
				if (attribSourcePropertyType != null)
				{
					global::System.String valueOfSourcePropertyType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourcePropertyType), out valueOfSourcePropertyType))
					{
						instanceOfManyToManyRelation.SourcePropertyType = valueOfSourcePropertyType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourcePropertyType", typeof(global::System.String), attribSourcePropertyType);
					}
				}
			}
			// TargetPropertyType
			if (!serializationContext.Result.Failed)
			{
				string attribTargetPropertyType = reader.GetAttribute("targetPropertyType");
				if (attribTargetPropertyType != null)
				{
					global::System.String valueOfTargetPropertyType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetPropertyType), out valueOfTargetPropertyType))
					{
						instanceOfManyToManyRelation.TargetPropertyType = valueOfTargetPropertyType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetPropertyType", typeof(global::System.String), attribTargetPropertyType);
					}
				}
			}
			// SourcePropertyName
			if (!serializationContext.Result.Failed)
			{
				string attribSourcePropertyName = reader.GetAttribute("sourcePropertyName");
				if (attribSourcePropertyName != null)
				{
					global::System.String valueOfSourcePropertyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourcePropertyName), out valueOfSourcePropertyName))
					{
						instanceOfManyToManyRelation.SourcePropertyName = valueOfSourcePropertyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourcePropertyName", typeof(global::System.String), attribSourcePropertyName);
					}
				}
			}
			// TargetPropertyName
			if (!serializationContext.Result.Failed)
			{
				string attribTargetPropertyName = reader.GetAttribute("targetPropertyName");
				if (attribTargetPropertyName != null)
				{
					global::System.String valueOfTargetPropertyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetPropertyName), out valueOfTargetPropertyName))
					{
						instanceOfManyToManyRelation.TargetPropertyName = valueOfTargetPropertyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetPropertyName", typeof(global::System.String), attribTargetPropertyName);
					}
				}
			}
			// TargetNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				string attribTargetNotFoundBehaviour = reader.GetAttribute("targetNotFoundBehaviour");
				if (attribTargetNotFoundBehaviour != null)
				{
					NotFoundBehaviour valueOfTargetNotFoundBehaviour;
					if (DslModeling::SerializationUtilities.TryGetValue<NotFoundBehaviour>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetNotFoundBehaviour), out valueOfTargetNotFoundBehaviour))
					{
						instanceOfManyToManyRelation.TargetNotFoundBehaviour = valueOfTargetNotFoundBehaviour;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetNotFoundBehaviour", typeof(NotFoundBehaviour), attribTargetNotFoundBehaviour);
					}
				}
			}
			// SourceNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				string attribSourceNotFoundBehaviour = reader.GetAttribute("sourceNotFoundBehaviour");
				if (attribSourceNotFoundBehaviour != null)
				{
					NotFoundBehaviour valueOfSourceNotFoundBehaviour;
					if (DslModeling::SerializationUtilities.TryGetValue<NotFoundBehaviour>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceNotFoundBehaviour), out valueOfSourceNotFoundBehaviour))
					{
						instanceOfManyToManyRelation.SourceNotFoundBehaviour = valueOfSourceNotFoundBehaviour;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceNotFoundBehaviour", typeof(NotFoundBehaviour), attribSourceNotFoundBehaviour);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToManyRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ManyToManyRelation based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ManyToManyRelation, a new ManyToManyRelation instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ManyToManyRelation instance, or null if the reader is not pointing to a serialized ManyToManyRelation instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ManyToManyRelation based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ManyToManyRelation type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ManyToManyRelation, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToManyRelation" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ManyToManyRelation".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ManyToManyRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToManyRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ManyToManyRelation based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ManyToManyRelation.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ManyToManyRelation instance should be created.</param>	
		/// <returns>Created ManyToManyRelation instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (idStr == null)
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					ActiveWriterSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new ManyToManyRelation(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ManyToManyRelation.SourceDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ManyToManyRelation.TargetDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ManyToManyRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ManyToManyRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToManyRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ManyToManyRelation itself) instance of ManyToManyRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToManyRelation" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ManyToManyRelation".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ManyToManyRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToManyRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ManyToManyRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DslModeling::SerializationUtilities.UnescapeXmlString(reader.GetAttribute(this.MonikerAttributeName));
			if (monikerString == null)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ManyToManyRelation.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToManyRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToManyRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToManyRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ManyToManyRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToManyRelation instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ManyToManyRelation instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ManyToManyRelation instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			writer.WriteAttributeString(this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ManyToManyRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToManyRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write the target role-player instance.
			ManyToManyRelation instance = element as ManyToManyRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToManyRelation!");
	
			DslModeling::ModelElement targetElement = instance.Target;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.Source, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToManyRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			ManyToManyRelation instanceOfManyToManyRelation = element as ManyToManyRelation;
			global::System.Diagnostics.Debug.Assert(instanceOfManyToManyRelation != null, "Expecting an instance of ManyToManyRelation");
	
			// SourceCache
			if (!serializationContext.Result.Failed)
			{
				CacheEnum propValue = instanceOfManyToManyRelation.SourceCache;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CacheEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Undefined") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceCache", serializedPropValue);
					}
				}
			}
			// SourceCascade
			if (!serializationContext.Result.Failed)
			{
				ManyRelationCascadeEnum propValue = instanceOfManyToManyRelation.SourceCascade;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<ManyRelationCascadeEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceCascade", serializedPropValue);
					}
				}
			}
			// SourceColumn
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceColumn;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourceColumn", propValue);
				}
			}
			// SourceCustomAccess
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceCustomAccess;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourceCustomAccess", propValue);
				}
			}
			// SourceInverse
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToManyRelation.SourceInverse;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceInverse", serializedPropValue);
					}
				}
			}
			// SourceLazy
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToManyRelation.SourceLazy;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceLazy", serializedPropValue);
					}
				}
			}
			// SourceMapType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceMapType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourceMapType", propValue);
				}
			}
			// SourceOrderBy
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceOrderBy;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourceOrderBy", propValue);
				}
			}
			// SourceRelationType
			if (!serializationContext.Result.Failed)
			{
				RelationType propValue = instanceOfManyToManyRelation.SourceRelationType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<RelationType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Guess") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceRelationType", serializedPropValue);
					}
				}
			}
			// Schema
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.Schema;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("schema", propValue);
				}
			}
			// SourceSort
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceSort;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourceSort", propValue);
				}
			}
			// Table
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.Table;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("table", propValue);
				}
			}
			// SourceWhere
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceWhere;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourceWhere", propValue);
				}
			}
			// TargetCache
			if (!serializationContext.Result.Failed)
			{
				CacheEnum propValue = instanceOfManyToManyRelation.TargetCache;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CacheEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Undefined") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetCache", serializedPropValue);
					}
				}
			}
			// TargetCascade
			if (!serializationContext.Result.Failed)
			{
				ManyRelationCascadeEnum propValue = instanceOfManyToManyRelation.TargetCascade;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<ManyRelationCascadeEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetCascade", serializedPropValue);
					}
				}
			}
			// TargetColumn
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetColumn;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetColumn", propValue);
				}
			}
			// TargetCustomAccess
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetCustomAccess;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetCustomAccess", propValue);
				}
			}
			// TargetInverse
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToManyRelation.TargetInverse;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetInverse", serializedPropValue);
					}
				}
			}
			// TargetLazy
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfManyToManyRelation.TargetLazy;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetLazy", serializedPropValue);
					}
				}
			}
			// TargetMapType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetMapType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetMapType", propValue);
				}
			}
			// TargetOrderBy
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetOrderBy;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetOrderBy", propValue);
				}
			}
			// TargetRelationType
			if (!serializationContext.Result.Failed)
			{
				RelationType propValue = instanceOfManyToManyRelation.TargetRelationType;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<RelationType>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Guess") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetRelationType", serializedPropValue);
					}
				}
			}
			// TargetSort
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetSort;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetSort", propValue);
				}
			}
			// TargetWhere
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetWhere;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetWhere", propValue);
				}
			}
			// SourceDescription
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourceDescription;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourceDescription", propValue);
				}
			}
			// TargetDescription
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetDescription;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetDescription", propValue);
				}
			}
			// SourceAccess
			if (!serializationContext.Result.Failed)
			{
				PropertyAccess propValue = instanceOfManyToManyRelation.SourceAccess;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<PropertyAccess>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Property") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceAccess", serializedPropValue);
					}
				}
			}
			// TargetAccess
			if (!serializationContext.Result.Failed)
			{
				PropertyAccess propValue = instanceOfManyToManyRelation.TargetAccess;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<PropertyAccess>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Property") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetAccess", serializedPropValue);
					}
				}
			}
			// SourcePropertyType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourcePropertyType;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "IList") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourcePropertyType", propValue);
					}
				}
			}
			// TargetPropertyType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetPropertyType;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "IList") != 0))
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetPropertyType", propValue);
					}
				}
			}
			// SourcePropertyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.SourcePropertyName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourcePropertyName", propValue);
				}
			}
			// TargetPropertyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfManyToManyRelation.TargetPropertyName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetPropertyName", propValue);
				}
			}
			// TargetNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				NotFoundBehaviour propValue = instanceOfManyToManyRelation.TargetNotFoundBehaviour;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NotFoundBehaviour>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Default") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetNotFoundBehaviour", serializedPropValue);
					}
				}
			}
			// SourceNotFoundBehaviour
			if (!serializationContext.Result.Failed)
			{
				NotFoundBehaviour propValue = instanceOfManyToManyRelation.SourceNotFoundBehaviour;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<NotFoundBehaviour>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Default") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceNotFoundBehaviour", serializedPropValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToManyRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ManyToManyRelation instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToManyRelation instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ManyToManyRelation instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToManyRelation instance = element as ManyToManyRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToManyRelation!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToManyRelation instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, ManyToManyRelation.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), ManyToManyRelation.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer OneToOneRelationSerializer for DomainClass OneToOneRelation.
	/// </summary>
	public partial class OneToOneRelationSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// OneToOneRelationSerializer Constructor
		/// </summary>
		public OneToOneRelationSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of OneToOneRelation.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"oneToOneRelation"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one OneToOneRelation instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the OneToOneRelation element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory OneToOneRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements, which include at least the monikerized instance of target role-player Target
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player Target.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "OneToOneRelation");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player Target.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory OneToOneRelation instance that will link to the target ModelClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player Target
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((OneToOneRelation)element).Source, OneToOneRelation.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, OneToOneRelation.TargetDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "OneToOneRelation");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory OneToOneRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			OneToOneRelation instanceOfOneToOneRelation = element as OneToOneRelation;
			global::System.Diagnostics.Debug.Assert(instanceOfOneToOneRelation != null, "Expecting an instance of OneToOneRelation");
	
			// SourceAccess
			if (!serializationContext.Result.Failed)
			{
				string attribSourceAccess = reader.GetAttribute("sourceAccess");
				if (attribSourceAccess != null)
				{
					PropertyAccess valueOfSourceAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<PropertyAccess>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceAccess), out valueOfSourceAccess))
					{
						instanceOfOneToOneRelation.SourceAccess = valueOfSourceAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceAccess", typeof(PropertyAccess), attribSourceAccess);
					}
				}
			}
			// SourceCascade
			if (!serializationContext.Result.Failed)
			{
				string attribSourceCascade = reader.GetAttribute("sourceCascade");
				if (attribSourceCascade != null)
				{
					CascadeEnum valueOfSourceCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<CascadeEnum>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceCascade), out valueOfSourceCascade))
					{
						instanceOfOneToOneRelation.SourceCascade = valueOfSourceCascade;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCascade", typeof(CascadeEnum), attribSourceCascade);
					}
				}
			}
			// SourceConstrained
			if (!serializationContext.Result.Failed)
			{
				string attribSourceConstrained = reader.GetAttribute("sourceConstrained");
				if (attribSourceConstrained != null)
				{
					global::System.Boolean valueOfSourceConstrained;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceConstrained), out valueOfSourceConstrained))
					{
						instanceOfOneToOneRelation.SourceConstrained = valueOfSourceConstrained;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceConstrained", typeof(global::System.Boolean), attribSourceConstrained);
					}
				}
			}
			// SourceCustomAccess
			if (!serializationContext.Result.Failed)
			{
				string attribSourceCustomAccess = reader.GetAttribute("sourceCustomAccess");
				if (attribSourceCustomAccess != null)
				{
					global::System.String valueOfSourceCustomAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceCustomAccess), out valueOfSourceCustomAccess))
					{
						instanceOfOneToOneRelation.SourceCustomAccess = valueOfSourceCustomAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCustomAccess", typeof(global::System.String), attribSourceCustomAccess);
					}
				}
			}
			// SourceOuterJoin
			if (!serializationContext.Result.Failed)
			{
				string attribSourceOuterJoin = reader.GetAttribute("sourceOuterJoin");
				if (attribSourceOuterJoin != null)
				{
					OuterJoinEnum valueOfSourceOuterJoin;
					if (DslModeling::SerializationUtilities.TryGetValue<OuterJoinEnum>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceOuterJoin), out valueOfSourceOuterJoin))
					{
						instanceOfOneToOneRelation.SourceOuterJoin = valueOfSourceOuterJoin;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceOuterJoin", typeof(OuterJoinEnum), attribSourceOuterJoin);
					}
				}
			}
			// TargetAccess
			if (!serializationContext.Result.Failed)
			{
				string attribTargetAccess = reader.GetAttribute("targetAccess");
				if (attribTargetAccess != null)
				{
					PropertyAccess valueOfTargetAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<PropertyAccess>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetAccess), out valueOfTargetAccess))
					{
						instanceOfOneToOneRelation.TargetAccess = valueOfTargetAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetAccess", typeof(PropertyAccess), attribTargetAccess);
					}
				}
			}
			// TargetCascade
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCascade = reader.GetAttribute("targetCascade");
				if (attribTargetCascade != null)
				{
					CascadeEnum valueOfTargetCascade;
					if (DslModeling::SerializationUtilities.TryGetValue<CascadeEnum>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetCascade), out valueOfTargetCascade))
					{
						instanceOfOneToOneRelation.TargetCascade = valueOfTargetCascade;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCascade", typeof(CascadeEnum), attribTargetCascade);
					}
				}
			}
			// TargetConstrained
			if (!serializationContext.Result.Failed)
			{
				string attribTargetConstrained = reader.GetAttribute("targetConstrained");
				if (attribTargetConstrained != null)
				{
					global::System.Boolean valueOfTargetConstrained;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetConstrained), out valueOfTargetConstrained))
					{
						instanceOfOneToOneRelation.TargetConstrained = valueOfTargetConstrained;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetConstrained", typeof(global::System.Boolean), attribTargetConstrained);
					}
				}
			}
			// TargetCustomAccess
			if (!serializationContext.Result.Failed)
			{
				string attribTargetCustomAccess = reader.GetAttribute("targetCustomAccess");
				if (attribTargetCustomAccess != null)
				{
					global::System.String valueOfTargetCustomAccess;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetCustomAccess), out valueOfTargetCustomAccess))
					{
						instanceOfOneToOneRelation.TargetCustomAccess = valueOfTargetCustomAccess;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCustomAccess", typeof(global::System.String), attribTargetCustomAccess);
					}
				}
			}
			// TargetOuterJoin
			if (!serializationContext.Result.Failed)
			{
				string attribTargetOuterJoin = reader.GetAttribute("targetOuterJoin");
				if (attribTargetOuterJoin != null)
				{
					OuterJoinEnum valueOfTargetOuterJoin;
					if (DslModeling::SerializationUtilities.TryGetValue<OuterJoinEnum>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetOuterJoin), out valueOfTargetOuterJoin))
					{
						instanceOfOneToOneRelation.TargetOuterJoin = valueOfTargetOuterJoin;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetOuterJoin", typeof(OuterJoinEnum), attribTargetOuterJoin);
					}
				}
			}
			// SourceDescription
			if (!serializationContext.Result.Failed)
			{
				string attribSourceDescription = reader.GetAttribute("sourceDescription");
				if (attribSourceDescription != null)
				{
					global::System.String valueOfSourceDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribSourceDescription), out valueOfSourceDescription))
					{
						instanceOfOneToOneRelation.SourceDescription = valueOfSourceDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceDescription", typeof(global::System.String), attribSourceDescription);
					}
				}
			}
			// TargetDescription
			if (!serializationContext.Result.Failed)
			{
				string attribTargetDescription = reader.GetAttribute("targetDescription");
				if (attribTargetDescription != null)
				{
					global::System.String valueOfTargetDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribTargetDescription), out valueOfTargetDescription))
					{
						instanceOfOneToOneRelation.TargetDescription = valueOfTargetDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetDescription", typeof(global::System.String), attribTargetDescription);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory OneToOneRelation instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of OneToOneRelation based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized OneToOneRelation, a new OneToOneRelation instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created OneToOneRelation instance, or null if the reader is not pointing to a serialized OneToOneRelation instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of OneToOneRelation based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// OneToOneRelation type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from OneToOneRelation, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "OneToOneRelation" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "OneToOneRelation".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						OneToOneRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as OneToOneRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of OneToOneRelation based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of OneToOneRelation.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new OneToOneRelation instance should be created.</param>	
		/// <returns>Created OneToOneRelation instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new OneToOneRelation(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (OneToOneRelation.SourceDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (OneToOneRelation.TargetDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from OneToOneRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from OneToOneRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(OneToOneRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including OneToOneRelation itself) instance of OneToOneRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "OneToOneRelation" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "OneToOneRelation".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						OneToOneRelationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as OneToOneRelationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of OneToOneRelation based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from OneToOneRelation, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from OneToOneRelation.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(OneToOneRelation.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized OneToOneRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOneRelation instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the OneToOneRelation instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the OneToOneRelation instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of OneToOneRelation cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "OneToOneRelation");
		}
		
		/// <summary>
		/// Public Write() method that serializes one OneToOneRelation instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOneRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write the target role-player instance.
			OneToOneRelation instance = element as OneToOneRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of OneToOneRelation!");
	
			DslModeling::ModelElement targetElement = instance.Target;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.Source, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOneRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			OneToOneRelation instanceOfOneToOneRelation = element as OneToOneRelation;
			global::System.Diagnostics.Debug.Assert(instanceOfOneToOneRelation != null, "Expecting an instance of OneToOneRelation");
	
			// SourceAccess
			if (!serializationContext.Result.Failed)
			{
				PropertyAccess propValue = instanceOfOneToOneRelation.SourceAccess;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<PropertyAccess>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Property") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceAccess", serializedPropValue);
					}
				}
			}
			// SourceCascade
			if (!serializationContext.Result.Failed)
			{
				CascadeEnum propValue = instanceOfOneToOneRelation.SourceCascade;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CascadeEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceCascade", serializedPropValue);
					}
				}
			}
			// SourceConstrained
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfOneToOneRelation.SourceConstrained;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceConstrained", serializedPropValue);
					}
				}
			}
			// SourceCustomAccess
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfOneToOneRelation.SourceCustomAccess;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourceCustomAccess", propValue);
				}
			}
			// SourceOuterJoin
			if (!serializationContext.Result.Failed)
			{
				OuterJoinEnum propValue = instanceOfOneToOneRelation.SourceOuterJoin;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<OuterJoinEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Auto") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("sourceOuterJoin", serializedPropValue);
					}
				}
			}
			// TargetAccess
			if (!serializationContext.Result.Failed)
			{
				PropertyAccess propValue = instanceOfOneToOneRelation.TargetAccess;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<PropertyAccess>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Property") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetAccess", serializedPropValue);
					}
				}
			}
			// TargetCascade
			if (!serializationContext.Result.Failed)
			{
				CascadeEnum propValue = instanceOfOneToOneRelation.TargetCascade;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<CascadeEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetCascade", serializedPropValue);
					}
				}
			}
			// TargetConstrained
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfOneToOneRelation.TargetConstrained;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetConstrained", serializedPropValue);
					}
				}
			}
			// TargetCustomAccess
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfOneToOneRelation.TargetCustomAccess;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetCustomAccess", propValue);
				}
			}
			// TargetOuterJoin
			if (!serializationContext.Result.Failed)
			{
				OuterJoinEnum propValue = instanceOfOneToOneRelation.TargetOuterJoin;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<OuterJoinEnum>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Auto") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("targetOuterJoin", serializedPropValue);
					}
				}
			}
			// SourceDescription
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfOneToOneRelation.SourceDescription;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("sourceDescription", propValue);
				}
			}
			// TargetDescription
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfOneToOneRelation.TargetDescription;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("targetDescription", propValue);
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOneRelation instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given OneToOneRelation instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">OneToOneRelation instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the OneToOneRelation instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			OneToOneRelation instance = element as OneToOneRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of OneToOneRelation!");
	
			DslModeling::ModelElement container = instance.Source;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">OneToOneRelation instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			OneToOneRelation instance = element as OneToOneRelation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of OneToOneRelation!");
			DslModeling::ModelElement container = instance.Source;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, OneToOneRelation.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), OneToOneRelation.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer ModelHasNestedClassesSerializer for DomainClass ModelHasNestedClasses.
	/// </summary>
	public partial class ModelHasNestedClassesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// ModelHasNestedClassesSerializer Constructor
		/// </summary>
		public ModelHasNestedClassesSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ModelHasNestedClasses.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"modelHasNestedClasses"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ModelHasNestedClasses instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ModelHasNestedClasses element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasNestedClasses instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player NestedClass
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player NestedClass.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelHasNestedClasses");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player NestedClass.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasNestedClasses instance that will link to the target NestedClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player NestedClass
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(NestedClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for NestedClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ModelHasNestedClasses.NestedClassDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelHasNestedClasses");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasNestedClasses instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ModelHasNestedClasses instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of ModelHasNestedClasses based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ModelHasNestedClasses, a new ModelHasNestedClasses instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ModelHasNestedClasses instance, or null if the reader is not pointing to a serialized ModelHasNestedClasses instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of ModelHasNestedClasses based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// ModelHasNestedClasses type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from ModelHasNestedClasses, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelHasNestedClasses" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ModelHasNestedClasses".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						ModelHasNestedClassesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelHasNestedClassesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ModelHasNestedClasses based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ModelHasNestedClasses.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ModelHasNestedClasses instance should be created.</param>	
		/// <returns>Created ModelHasNestedClasses instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new ModelHasNestedClasses(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelHasNestedClasses.ModelDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelHasNestedClasses.NestedClassDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelHasNestedClasses, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelHasNestedClasses.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelHasNestedClasses.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ModelHasNestedClasses itself) instance of ModelHasNestedClasses based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ModelHasNestedClasses" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ModelHasNestedClasses".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ModelHasNestedClassesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelHasNestedClassesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ModelHasNestedClasses based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelHasNestedClasses, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelHasNestedClasses.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelHasNestedClasses.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ModelHasNestedClasses instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasNestedClasses instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ModelHasNestedClasses instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelHasNestedClasses instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ModelHasNestedClasses cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ModelHasNestedClasses");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ModelHasNestedClasses instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasNestedClasses instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasNestedClasses instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ModelHasNestedClasses instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelHasNestedClasses instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelHasNestedClasses instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelHasNestedClasses instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelHasNestedClasses instance = element as ModelHasNestedClasses;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelHasNestedClasses!");
	
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelHasNestedClasses instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelHasNestedClasses instance = element as ModelHasNestedClasses;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelHasNestedClasses!");
			DslModeling::ModelElement container = instance.Model;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer NestedClassHasPropertiesSerializer for DomainClass NestedClassHasProperties.
	/// </summary>
	public partial class NestedClassHasPropertiesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// NestedClassHasPropertiesSerializer Constructor
		/// </summary>
		public NestedClassHasPropertiesSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of NestedClassHasProperties.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nestedClassHasProperties"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one NestedClassHasProperties instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the NestedClassHasProperties element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassHasProperties instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Property
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player Property.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "NestedClassHasProperties");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player Property.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassHasProperties instance that will link to the target ModelProperty instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Property
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelProperty.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelProperty!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, NestedClassHasProperties.PropertyDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "NestedClassHasProperties");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassHasProperties instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassHasProperties instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of NestedClassHasProperties based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized NestedClassHasProperties, a new NestedClassHasProperties instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created NestedClassHasProperties instance, or null if the reader is not pointing to a serialized NestedClassHasProperties instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of NestedClassHasProperties based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// NestedClassHasProperties type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from NestedClassHasProperties, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClassHasProperties" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "NestedClassHasProperties".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						NestedClassHasPropertiesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassHasPropertiesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of NestedClassHasProperties based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of NestedClassHasProperties.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new NestedClassHasProperties instance should be created.</param>	
		/// <returns>Created NestedClassHasProperties instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new NestedClassHasProperties(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (NestedClassHasProperties.NestedClassDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (NestedClassHasProperties.PropertyDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from NestedClassHasProperties, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from NestedClassHasProperties.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClassHasProperties.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including NestedClassHasProperties itself) instance of NestedClassHasProperties based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClassHasProperties" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "NestedClassHasProperties".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						NestedClassHasPropertiesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassHasPropertiesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of NestedClassHasProperties based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClassHasProperties, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClassHasProperties.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClassHasProperties.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized NestedClassHasProperties instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassHasProperties instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the NestedClassHasProperties instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the NestedClassHasProperties instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of NestedClassHasProperties cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "NestedClassHasProperties");
		}
		
		/// <summary>
		/// Public Write() method that serializes one NestedClassHasProperties instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassHasProperties instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassHasProperties instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassHasProperties instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given NestedClassHasProperties instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClassHasProperties instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the NestedClassHasProperties instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedClassHasProperties instance = element as NestedClassHasProperties;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClassHasProperties!");
	
			DslModeling::ModelElement container = instance.NestedClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClassHasProperties instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedClassHasProperties instance = element as NestedClassHasProperties;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClassHasProperties!");
			DslModeling::ModelElement container = instance.NestedClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return false;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer NestedClassReferencesModelClassesSerializer for DomainClass NestedClassReferencesModelClasses.
	/// </summary>
	public partial class NestedClassReferencesModelClassesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// NestedClassReferencesModelClassesSerializer Constructor
		/// </summary>
		public NestedClassReferencesModelClassesSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of NestedClassReferencesModelClasses.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nestedClassReferencesModelClasses"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one NestedClassReferencesModelClasses instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the NestedClassReferencesModelClasses element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassReferencesModelClasses instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements, which include at least the monikerized instance of target role-player ModelClass
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read target role-player ModelClass.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "NestedClassReferencesModelClasses");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		/// <summary>
		/// This method reads the target role player ModelClass.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassReferencesModelClasses instance that will link to the target ModelClass instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player ModelClass
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((NestedClassReferencesModelClasses)element).NestedClass, NestedClassReferencesModelClasses.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, NestedClassReferencesModelClasses.ModelClassDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "NestedClassReferencesModelClasses");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassReferencesModelClasses instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			NestedClassReferencesModelClasses instanceOfNestedClassReferencesModelClasses = element as NestedClassReferencesModelClasses;
			global::System.Diagnostics.Debug.Assert(instanceOfNestedClassReferencesModelClasses != null, "Expecting an instance of NestedClassReferencesModelClasses");
	
			// MapType
			if (!serializationContext.Result.Failed)
			{
				string attribMapType = reader.GetAttribute("mapType");
				if (attribMapType != null)
				{
					global::System.String valueOfMapType;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribMapType), out valueOfMapType))
					{
						instanceOfNestedClassReferencesModelClasses.MapType = valueOfMapType;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "mapType", typeof(global::System.String), attribMapType);
					}
				}
			}
			// Insert
			if (!serializationContext.Result.Failed)
			{
				string attribInsert = reader.GetAttribute("insert");
				if (attribInsert != null)
				{
					global::System.Boolean valueOfInsert;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribInsert), out valueOfInsert))
					{
						instanceOfNestedClassReferencesModelClasses.Insert = valueOfInsert;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "insert", typeof(global::System.Boolean), attribInsert);
					}
				}
			}
			// Update
			if (!serializationContext.Result.Failed)
			{
				string attribUpdate = reader.GetAttribute("update");
				if (attribUpdate != null)
				{
					global::System.Boolean valueOfUpdate;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(DslModeling::SerializationUtilities.UnescapeXmlString(attribUpdate), out valueOfUpdate))
					{
						instanceOfNestedClassReferencesModelClasses.Update = valueOfUpdate;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "update", typeof(global::System.Boolean), attribUpdate);
					}
				}
			}
			// ColumnPrefix
			if (!serializationContext.Result.Failed)
			{
				string attribColumnPrefix = reader.GetAttribute("columnPrefix");
				if (attribColumnPrefix != null)
				{
					global::System.String valueOfColumnPrefix;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribColumnPrefix), out valueOfColumnPrefix))
					{
						instanceOfNestedClassReferencesModelClasses.ColumnPrefix = valueOfColumnPrefix;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "columnPrefix", typeof(global::System.String), attribColumnPrefix);
					}
				}
			}
			// Description
			if (!serializationContext.Result.Failed)
			{
				string attribDescription = reader.GetAttribute("description");
				if (attribDescription != null)
				{
					global::System.String valueOfDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribDescription), out valueOfDescription))
					{
						instanceOfNestedClassReferencesModelClasses.Description = valueOfDescription;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "description", typeof(global::System.String), attribDescription);
					}
				}
			}
			// PropertyName
			if (!serializationContext.Result.Failed)
			{
				string attribPropertyName = reader.GetAttribute("propertyName");
				if (attribPropertyName != null)
				{
					global::System.String valueOfPropertyName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(DslModeling::SerializationUtilities.UnescapeXmlString(attribPropertyName), out valueOfPropertyName))
					{
						instanceOfNestedClassReferencesModelClasses.PropertyName = valueOfPropertyName;
					}
					else
					{	// Invalid property value, ignored.
						ActiveWriterSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "propertyName", typeof(global::System.String), attribPropertyName);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies the if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassReferencesModelClasses instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of NestedClassReferencesModelClasses based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized NestedClassReferencesModelClasses, a new NestedClassReferencesModelClasses instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created NestedClassReferencesModelClasses instance, or null if the reader is not pointing to a serialized NestedClassReferencesModelClasses instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of NestedClassReferencesModelClasses based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// NestedClassReferencesModelClasses type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from NestedClassReferencesModelClasses, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClassReferencesModelClasses" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "NestedClassReferencesModelClasses".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						NestedClassReferencesModelClassesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassReferencesModelClassesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of NestedClassReferencesModelClasses based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of NestedClassReferencesModelClasses.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new NestedClassReferencesModelClasses instance should be created.</param>	
		/// <returns>Created NestedClassReferencesModelClasses instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Create the link with place-holder role-players.
			return new NestedClassReferencesModelClasses(
				partition,
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (NestedClassReferencesModelClasses.NestedClassDomainRoleId), 
				DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (NestedClassReferencesModelClasses.ModelClassDomainRoleId)
			);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from NestedClassReferencesModelClasses, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from NestedClassReferencesModelClasses.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClassReferencesModelClasses.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including NestedClassReferencesModelClasses itself) instance of NestedClassReferencesModelClasses based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClassReferencesModelClasses" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "NestedClassReferencesModelClasses".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						NestedClassReferencesModelClassesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassReferencesModelClassesSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of NestedClassReferencesModelClasses based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClassReferencesModelClasses, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClassReferencesModelClasses.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClassReferencesModelClasses.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized NestedClassReferencesModelClasses instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassReferencesModelClasses instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the NestedClassReferencesModelClasses instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the NestedClassReferencesModelClasses instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of NestedClassReferencesModelClasses cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "NestedClassReferencesModelClasses");
		}
		
		/// <summary>
		/// Public Write() method that serializes one NestedClassReferencesModelClasses instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassReferencesModelClasses instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write the target role-player instance.
			NestedClassReferencesModelClasses instance = element as NestedClassReferencesModelClasses;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClassReferencesModelClasses!");
	
			DslModeling::ModelElement targetElement = instance.ModelClass;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.NestedClass, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassReferencesModelClasses instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>	
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected virtual void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			NestedClassReferencesModelClasses instanceOfNestedClassReferencesModelClasses = element as NestedClassReferencesModelClasses;
			global::System.Diagnostics.Debug.Assert(instanceOfNestedClassReferencesModelClasses != null, "Expecting an instance of NestedClassReferencesModelClasses");
	
			// MapType
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfNestedClassReferencesModelClasses.MapType;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("mapType", propValue);
				}
			}
			// Insert
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfNestedClassReferencesModelClasses.Insert;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("insert", serializedPropValue);
					}
				}
			}
			// Update
			if (!serializationContext.Result.Failed)
			{
				global::System.Boolean propValue = instanceOfNestedClassReferencesModelClasses.Update;
				string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
				if (!serializationContext.Result.Failed)
				{
					if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
					{	// No need to write the value out if it's the same as default value.
						writer.WriteAttributeString("update", serializedPropValue);
					}
				}
			}
			// ColumnPrefix
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfNestedClassReferencesModelClasses.ColumnPrefix;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("columnPrefix", propValue);
				}
			}
			// Description
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfNestedClassReferencesModelClasses.Description;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("description", propValue);
				}
			}
			// PropertyName
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfNestedClassReferencesModelClasses.PropertyName;
				if (!serializationContext.Result.Failed)
				{
					if (!string.IsNullOrEmpty(propValue))
						writer.WriteAttributeString("propertyName", propValue);
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassReferencesModelClasses instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected virtual void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given NestedClassReferencesModelClasses instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClassReferencesModelClasses instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the NestedClassReferencesModelClasses instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedClassReferencesModelClasses instance = element as NestedClassReferencesModelClasses;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClassReferencesModelClasses!");
	
			DslModeling::ModelElement container = instance.NestedClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClassReferencesModelClasses instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedClassReferencesModelClasses instance = element as NestedClassReferencesModelClasses;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClassReferencesModelClasses!");
			DslModeling::ModelElement container = instance.NestedClass;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of NestedClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is NestedClass, "Expecting an instance of NestedClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, NestedClassReferencesModelClasses.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), NestedClassReferencesModelClasses.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is NestedClass, "Expecting an instance of NestedClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return false;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer ClassShapeSerializerBase for DomainClass ClassShape.
	/// </summary>
	public abstract partial class ClassShapeSerializerBase : DslDiagrams::CompartmentShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// ClassShapeSerializerBase Constructor
		/// </summary>
		protected ClassShapeSerializerBase ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ClassShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"classShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of ClassShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"classShapeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of ClassShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ClassShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ClassShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ClassShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ClassShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ClassShape, a new ClassShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ClassShape instance, or null if the reader is not pointing to a serialized ClassShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ClassShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ClassShapeSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassShapeSerializerBase;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ClassShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ClassShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ClassShape instance should be created.</param>	
		/// <returns>Created ClassShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (idStr == null)
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					ActiveWriterSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new ClassShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ClassShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ClassShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ClassShape itself) instance of ClassShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ClassShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ClassShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ClassShapeSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassShapeSerializerBase;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ClassShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DslModeling::SerializationUtilities.UnescapeXmlString(reader.GetAttribute(this.MonikerAttributeName));
			if (monikerString == null)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ClassShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ClassShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ClassShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ClassShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			writer.WriteAttributeString(this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one ClassShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ClassShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ClassShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ClassShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassShape instance = element as ClassShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
	
	/// <summary>
	/// Serializer ClassShapeSerializer for DomainClass ClassShape.
	/// </summary>
	public partial class ClassShapeSerializer : ClassShapeSerializerBase
	{
		#region Constructor
		/// <summary>
		/// ClassShapeSerializer Constructor
		/// </summary>
		public ClassShapeSerializer ()
			: base ()
		{
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer NestedClassShapeSerializerBase for DomainClass NestedClassShape.
	/// </summary>
	public abstract partial class NestedClassShapeSerializerBase : DslDiagrams::CompartmentShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// NestedClassShapeSerializerBase Constructor
		/// </summary>
		protected NestedClassShapeSerializerBase ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of NestedClassShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nestedClassShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of NestedClassShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nestedClassShapeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of NestedClassShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one NestedClassShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the NestedClassShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedClassShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of NestedClassShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized NestedClassShape, a new NestedClassShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created NestedClassShape instance, or null if the reader is not pointing to a serialized NestedClassShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClassShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "NestedClassShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						NestedClassShapeSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassShapeSerializerBase;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of NestedClassShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of NestedClassShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new NestedClassShape instance should be created.</param>	
		/// <returns>Created NestedClassShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (idStr == null)
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					ActiveWriterSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new NestedClassShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from NestedClassShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from NestedClassShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClassShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including NestedClassShape itself) instance of NestedClassShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedClassShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "NestedClassShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						NestedClassShapeSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedClassShapeSerializerBase;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of NestedClassShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = DslModeling::SerializationUtilities.UnescapeXmlString(reader.GetAttribute(this.MonikerAttributeName));
			if (monikerString == null)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, NestedClassShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				ActiveWriterSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClassShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedClassShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedClassShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized NestedClassShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the NestedClassShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the NestedClassShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			writer.WriteAttributeString(this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one NestedClassShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedClassShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given NestedClassShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClassShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the NestedClassShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedClassShape instance = element as NestedClassShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedClassShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedClassShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
	
	/// <summary>
	/// Serializer NestedClassShapeSerializer for DomainClass NestedClassShape.
	/// </summary>
	public partial class NestedClassShapeSerializer : NestedClassShapeSerializerBase
	{
		#region Constructor
		/// <summary>
		/// NestedClassShapeSerializer Constructor
		/// </summary>
		public NestedClassShapeSerializer ()
			: base ()
		{
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer ManyToOneConnectorSerializer for DomainClass ManyToOneConnector.
	/// </summary>
	public partial class ManyToOneConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// ManyToOneConnectorSerializer Constructor
		/// </summary>
		public ManyToOneConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ManyToOneConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToOneConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ManyToOneConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ManyToOneConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToOneConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ManyToOneConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ManyToOneConnector, a new ManyToOneConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ManyToOneConnector instance, or null if the reader is not pointing to a serialized ManyToOneConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToOneConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ManyToOneConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ManyToOneConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToOneConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ManyToOneConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ManyToOneConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ManyToOneConnector instance should be created.</param>	
		/// <returns>Created ManyToOneConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new ManyToOneConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ManyToOneConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ManyToOneConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToOneConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ManyToOneConnector itself) instance of ManyToOneConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToOneConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ManyToOneConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ManyToOneConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToOneConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ManyToOneConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToOneConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToOneConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToOneConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ManyToOneConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToOneConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ManyToOneConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ManyToOneConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ManyToOneConnector cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ManyToOneConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ManyToOneConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToOneConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ManyToOneConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToOneConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ManyToOneConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToOneConnector instance = element as ManyToOneConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToOneConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToOneConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToOneConnector instance = element as ManyToOneConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToOneConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer ManyToManyConnectorSerializer for DomainClass ManyToManyConnector.
	/// </summary>
	public partial class ManyToManyConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// ManyToManyConnectorSerializer Constructor
		/// </summary>
		public ManyToManyConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ManyToManyConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"manyToManyConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ManyToManyConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ManyToManyConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ManyToManyConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ManyToManyConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ManyToManyConnector, a new ManyToManyConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ManyToManyConnector instance, or null if the reader is not pointing to a serialized ManyToManyConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToManyConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ManyToManyConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ManyToManyConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToManyConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ManyToManyConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ManyToManyConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ManyToManyConnector instance should be created.</param>	
		/// <returns>Created ManyToManyConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new ManyToManyConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ManyToManyConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ManyToManyConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToManyConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ManyToManyConnector itself) instance of ManyToManyConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ManyToManyConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ManyToManyConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ManyToManyConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ManyToManyConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ManyToManyConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToManyConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ManyToManyConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ManyToManyConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ManyToManyConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToManyConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ManyToManyConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ManyToManyConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ManyToManyConnector cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ManyToManyConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ManyToManyConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ManyToManyConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ManyToManyConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToManyConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ManyToManyConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToManyConnector instance = element as ManyToManyConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToManyConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ManyToManyConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ManyToManyConnector instance = element as ManyToManyConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ManyToManyConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer OneToOneConnectorSerializer for DomainClass OneToOneConnector.
	/// </summary>
	public partial class OneToOneConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// OneToOneConnectorSerializer Constructor
		/// </summary>
		public OneToOneConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of OneToOneConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"oneToOneConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one OneToOneConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the OneToOneConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory OneToOneConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of OneToOneConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized OneToOneConnector, a new OneToOneConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created OneToOneConnector instance, or null if the reader is not pointing to a serialized OneToOneConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "OneToOneConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "OneToOneConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						OneToOneConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as OneToOneConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of OneToOneConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of OneToOneConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new OneToOneConnector instance should be created.</param>	
		/// <returns>Created OneToOneConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new OneToOneConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from OneToOneConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from OneToOneConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(OneToOneConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including OneToOneConnector itself) instance of OneToOneConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "OneToOneConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "OneToOneConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						OneToOneConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as OneToOneConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of OneToOneConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from OneToOneConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from OneToOneConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(OneToOneConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized OneToOneConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOneConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the OneToOneConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the OneToOneConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of OneToOneConnector cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "OneToOneConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one OneToOneConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">OneToOneConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given OneToOneConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">OneToOneConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the OneToOneConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			OneToOneConnector instance = element as OneToOneConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of OneToOneConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">OneToOneConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			OneToOneConnector instance = element as OneToOneConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of OneToOneConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer NestedConnectorSerializer for DomainClass NestedConnector.
	/// </summary>
	public partial class NestedConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// NestedConnectorSerializer Constructor
		/// </summary>
		public NestedConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of NestedConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"nestedConnector"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one NestedConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the NestedConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NestedConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of NestedConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized NestedConnector, a new NestedConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created NestedConnector instance, or null if the reader is not pointing to a serialized NestedConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "NestedConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						NestedConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of NestedConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of NestedConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new NestedConnector instance should be created.</param>	
		/// <returns>Created NestedConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new NestedConnector(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from NestedConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from NestedConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including NestedConnector itself) instance of NestedConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "NestedConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "NestedConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						NestedConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NestedConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of NestedConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from NestedConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NestedConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized NestedConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the NestedConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the NestedConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of NestedConnector cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "NestedConnector");
		}
		
		/// <summary>
		/// Public Write() method that serializes one NestedConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NestedConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given NestedConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the NestedConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedConnector instance = element as NestedConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedConnector!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NestedConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NestedConnector instance = element as NestedConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NestedConnector!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Serializer ActiveRecordMappingSerializer for DomainClass ActiveRecordMapping.
	/// </summary>
	public partial class ActiveRecordMappingSerializer : DslDiagrams::DiagramSerializer
	{
		#region Constructor
		/// <summary>
		/// ActiveRecordMappingSerializer Constructor
		/// </summary>
		public ActiveRecordMappingSerializer ()
			: base ()
		{
		}
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of ActiveRecordMapping.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"activeRecordMapping"; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one ActiveRecordMapping instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the ActiveRecordMapping element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory ActiveRecordMapping instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							ActiveWriterSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of ActiveRecordMapping based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized ActiveRecordMapping, a new ActiveRecordMapping instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created ActiveRecordMapping instance, or null if the reader is not pointing to a serialized ActiveRecordMapping instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ActiveRecordMapping" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "ActiveRecordMapping".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ActiveRecordMappingSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ActiveRecordMappingSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of ActiveRecordMapping based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of ActiveRecordMapping.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new ActiveRecordMapping instance should be created.</param>	
		/// <returns>Created ActiveRecordMapping instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			return new ActiveRecordMapping(partition);
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from ActiveRecordMapping, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from ActiveRecordMapping.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ActiveRecordMapping.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including ActiveRecordMapping itself) instance of ActiveRecordMapping based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "ActiveRecordMapping" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "ActiveRecordMapping".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ActiveRecordMappingSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ActiveRecordMappingSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of ActiveRecordMapping based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			// Cannot be monikerized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ActiveRecordMapping, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ActiveRecordMapping.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ActiveRecordMapping.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized ActiveRecordMapping instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ActiveRecordMapping instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the ActiveRecordMapping instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ActiveRecordMapping instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of ActiveRecordMapping cannot be monikerized.
			ActiveWriterSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ActiveRecordMapping");
		}
		
		/// <summary>
		/// Public Write() method that serializes one ActiveRecordMapping instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">ActiveRecordMapping instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods", Justification = "Parameter 'rootElementSettings' can be null, so no need to validate.")]
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			else
				writer.WriteStartElement(this.XmlTagName);
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ActiveRecordMapping instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ActiveRecordMapping instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ActiveRecordMapping instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ActiveRecordMapping instance = element as ActiveRecordMapping;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ActiveRecordMapping!");
	
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ActiveRecordMapping instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ActiveRecordMapping instance = element as ActiveRecordMapping;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ActiveRecordMapping!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// A DomainXmlSerializationBehavior implementation for defined behavior ActiveWriterSerializationBehavior.
	/// This is the abstract base of the double-derived implementation.
	/// </summary>
	public abstract class ActiveWriterSerializationBehaviorBase : DslModeling::DomainXmlSerializationBehavior
	{
		#region Member Variables
		/// <summary>
		/// A dictionary that maps DomainClass Id to DomainClassXmlSerializer types.
		/// </summary>
		private static global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerDirectoryEntry> serializerTypes;
		#endregion
	
		#region Constructor
		/// <summary>
		/// Protected constructor to prevent public instantiation.
		/// </summary>
		protected ActiveWriterSerializationBehaviorBase() : base() { }
		#endregion
		
		#region Protected Methods
		/// <summary>
		/// Allows custom serializers to be added.
		/// Base implementation doesn't do anything.
		/// </summary>
		/// <returns>Custom serializer types, null or empty list if there's no custom serializer types.</returns>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
		protected virtual global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> CustomSerializerTypes
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return null; }
		}
		#endregion
	
		#region Public Methods
		/// <summary>
		/// This provides a mapping from DomainClass Id to DomainXmlSerializer implementation types.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		public override global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> AllSerializers
		{
			get
			{
				if (ActiveWriterSerializationBehavior.serializerTypes == null)
				{
					global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> customSerializerTypes = this.CustomSerializerTypes;
					int customSerializerCount = (customSerializerTypes == null ? 0 : customSerializerTypes.Count);
					ActiveWriterSerializationBehavior.serializerTypes = new global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerDirectoryEntry>(21 + customSerializerCount);
	
					#region Serializers defined in this model
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Model.DomainClassId, typeof(ModelSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelClass.DomainClassId, typeof(ModelClassSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelProperty.DomainClassId, typeof(ModelPropertySerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelElementWithAccess.DomainClassId, typeof(ModelElementWithAccessSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(NamedElement.DomainClassId, typeof(NamedElementSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(NestedClass.DomainClassId, typeof(NestedClassSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelHasClass.DomainClassId, typeof(ModelHasClassSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ManyToOneRelation.DomainClassId, typeof(ManyToOneRelationSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ClassHasProperty.DomainClassId, typeof(ClassHasPropertySerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ManyToManyRelation.DomainClassId, typeof(ManyToManyRelationSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(OneToOneRelation.DomainClassId, typeof(OneToOneRelationSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelHasNestedClasses.DomainClassId, typeof(ModelHasNestedClassesSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(NestedClassHasProperties.DomainClassId, typeof(NestedClassHasPropertiesSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(NestedClassReferencesModelClasses.DomainClassId, typeof(NestedClassReferencesModelClassesSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ClassShape.DomainClassId, typeof(ClassShapeSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(NestedClassShape.DomainClassId, typeof(NestedClassShapeSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ManyToOneConnector.DomainClassId, typeof(ManyToOneConnectorSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ManyToManyConnector.DomainClassId, typeof(ManyToManyConnectorSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(OneToOneConnector.DomainClassId, typeof(OneToOneConnectorSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(NestedConnector.DomainClassId, typeof(NestedConnectorSerializer)));
					ActiveWriterSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ActiveRecordMapping.DomainClassId, typeof(ActiveRecordMappingSerializer)));
					#endregion
					
					// Custom ones
					if (customSerializerCount > 0)
					{
						ActiveWriterSerializationBehavior.serializerTypes.AddRange(customSerializerTypes);
					}
				}
				return ActiveWriterSerializationBehavior.serializerTypes.AsReadOnly();
			}
		}
		#endregion
	}
	
	/// <summary>
	/// A DomainXmlSerializationBehavior implementation for defined behavior ActiveWriterSerializationBehavior.
	/// This is the concrete type of the double-derived implementation.
	/// </summary>
	public sealed partial class ActiveWriterSerializationBehavior : ActiveWriterSerializationBehaviorBase
	{
		#region Singleton Instance
		/// <summary>
		/// Singleton instance.
		/// </summary>
		private static ActiveWriterSerializationBehavior instance;
	
		/// <summary>
		/// Singleton instance.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		public static ActiveWriterSerializationBehavior Instance
		{
			get
			{	// No need for synchronization. Most likely running in single-thread environment, and creating an extra instance
				// doesn't really hurt.
				if (ActiveWriterSerializationBehavior.instance == null)
					ActiveWriterSerializationBehavior.instance = new ActiveWriterSerializationBehavior ();
				return ActiveWriterSerializationBehavior.instance;
			}
		}
	
		/// <summary>
		/// Private constructor to prevent public instantiation.
		/// </summary>
		private ActiveWriterSerializationBehavior() : base() { }
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Moniker resolver for serialization behavior ActiveWriterSerializationBehavior.
	/// </summary>
	public partial class ActiveWriterSerializationBehaviorMonikerResolver : DslModeling::SimpleMonikerResolver
	{
		#region Member Variables
		/// <summary>
		/// Look-up directory to find serializers for domain classes.
		/// </summary>
		private DslModeling::DomainXmlSerializerDirectory directory;
		#endregion
	
		#region Constructor
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="store">Store for this moniker resolver.</param>
		/// <param name="directory">Directory to used by this resolver to look up for serializers.</param>
		public ActiveWriterSerializationBehaviorMonikerResolver(DslModeling::Store store, DslModeling::DomainXmlSerializerDirectory directory)
			: base (store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException("directory");
			#endregion
	
			this.directory = directory;
		}
		#endregion
	
		#region Base Overrides
		/// <summary>
		/// Tells if a DomainClass can be monikerized or not.
		/// </summary>
		/// <param name="domainClassInfo">DomainClassInfo of the DomainClass to be checked.</param>
		/// <returns>True if the DomainClass can be monikerized, false otherwise.</returns>
		protected override bool CanBeMonikerized(DslModeling::DomainClassInfo domainClassInfo)
		{
			if (this.IsDisposed || this.directory == null || domainClassInfo == null)
				return false;
				
			DslModeling::DomainClassXmlSerializer serializer = this.directory.GetSerializer(domainClassInfo.Id);
			if (serializer != null)
				return (!string.IsNullOrEmpty(serializer.MonikerTagName));
			return false;
		}
			
		/// <summary>
		/// Calculate the fully qualified monikerized string of the given ModelElement.
		/// </summary>
		/// <param name="mel">ModelElement to get moniker from.</param>
		/// <returns>Calculated moniker string, returns null or empty string is the given ModelElement cannot be monikerized.</returns>
		protected override string CalculateQualifiedName(DslModeling::ModelElement mel)
		{
			if (this.IsDisposed || this.directory == null || mel == null)
				return string.Empty;
	
			string result = string.Empty;
			DslModeling::DomainClassXmlSerializer serializer = this.directory.GetSerializer(mel.GetDomainClass().Id);
			if (serializer != null)
				result = serializer.CalculateQualifiedName(this.directory, mel);
			return result;
		}
		
		/// <summary>
		/// Called at the end of synchronization when they're unresolved monikers.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to store error/warning messages.</param>
		/// <param name="moniker">Unresolved moniker.</param>
		protected override void OnUnresolvedMoniker(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			if (serializationResult != null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.UnresolvedMoniker(serializationResult, moniker);
			}
		}
		
		/// <summary>
		/// Called when resolving a moniker causes a duplicate link to be created.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to store error/warning messages.</param>
		/// <param name="moniker">Moniker that causes duplicate link to be created.</param>
		protected override void OnMonikerResolvedToDuplicateLink(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			if (serializationResult != null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.MonikerResolvedToDuplicateLink(serializationResult, moniker);
			}
			base.OnMonikerResolvedToDuplicateLink(serializationResult, moniker);
		}
		
		/// <summary>
		/// Called when two new elements are giving the same moniker, which will cause ambiguity during moniker resolution.
		/// </summary>
		/// <param name="context">SerializationContext to store error/warning messages.</param>
		/// <param name="moniker">Moniker that both elements give.</param>
		/// <param name="element1">The first element giving the moniker.</param>
		/// <param name="element2">The second element giving the same moniker.</param>
		protected override void OnAmbiguousMoniker(DslModeling::SerializationContext context, string moniker, DslModeling::ModelElement element1, DslModeling::ModelElement element2)
		{
			if (context != null)
			{
				ActiveWriterSerializationBehaviorSerializationMessages.AmbiguousMoniker(context, moniker, element1, element2);
			}
			base.OnAmbiguousMoniker(context, moniker, element1, element2);
		}
		
		/// <summary>
		/// Error message for UnresolvedMonikerException.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
		protected override string UnresolvedMonikerExceptionMessage
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return ActiveWriterSerializationBehaviorSerializationMessages.ResourceManager.GetString("CannotOpenDocument"); }
		}
		#endregion
	}
}

namespace Altinoren.ActiveWriter
{
	/// <summary>
	/// Utility class to provide serialization messages
	/// </summary>
	public static partial class ActiveWriterSerializationBehaviorSerializationMessages
	{
		/// <summary>
		/// ResourceManager to get serialization messages from.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)] // Will trigger creation otherwise.
		public static global::System.Resources.ResourceManager ResourceManager
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return ActiveWriterDomainModel.SingletonResourceManager; }
		}
	
		#region Warnings
		/// <summary>
		/// Add a warning for ambiguous schemas.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="targetNamespace">Target namespace to be resolved.</param>
		/// <param name="schemaPath">The schema that is used to resolve the definition of the target namespace.</param>
		public static void AmbiguousSchema(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string targetNamespace, string schemaPath)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(targetNamespace));
			if (string.IsNullOrEmpty(targetNamespace))
				throw new global::System.ArgumentNullException("targetNamespace");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(schemaPath));
			if (string.IsNullOrEmpty(schemaPath))
				throw new global::System.ArgumentNullException("schemaPath");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("AmbiguousSchema"),
					targetNamespace,
					schemaPath
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning when a full-form relationship seems to be serialized in short-form.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type of the relationship.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the relationship, making it MemberInfo only adds confusion.")]
		public static void ExpectingFullFormRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Type relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(relationshipType != null);
			if (relationshipType == null)
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("ExpectingFullFormRelationship"),
					reader.Name,
					relationshipType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning when a short-form relationship seems to be serialized in full-form.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type of the relationship.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the relationship, making it MemberInfo only adds confusion.")]
		public static void ExpectingShortFormRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Type relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(relationshipType != null);
			if (relationshipType == null)
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("ExpectingShortFormRelationship"),
					relationshipType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for invalid property value with the given type, which will be ignored.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <param name="propertyType">Type of the property.</param>
		/// <param name="value">Invalid value that causes this warning.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the property, making it MemberInfo only adds confusion.")]
		public static void IgnoredPropertyValue(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string propertyName, global::System.Type propertyType, string value)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(propertyType != null);
			if (propertyType == null)
				throw new global::System.ArgumentNullException("propertyType");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(propertyName));
			if (string.IsNullOrEmpty(propertyName))
				throw new global::System.ArgumentNullException("propertyName");
			#endregion
			
			if (value == null)
				value = "<null>";
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("IgnoredPropertyValue"),
					value,
					propertyName,
					propertyType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for missing "Id" property.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="newId">Auto-generated new Id.</param>
		public static void MissingId(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Guid newId)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MissingId"),
					newId.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture)
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
			
		/// <summary>
		/// Add an warning for moniker resolved to duplicate link. The moniker will be ignored.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to add the error message to.</param>
		/// <param name="moniker">Offending moniker.</param>
		public static void MonikerResolvedToDuplicateLink(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationResult,
				moniker.Location,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MonikerResolvedToDuplicateLink"),
					moniker.MonikerName
				),
				moniker.Line,
				moniker.Column
			);
		}
		
		/// <summary>
		/// Add a warning for no schema found for the given target namespace, schema validation will be skipped in this case.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="targetNamespace">Target namespace that cannot be resolved.</param>
		public static void NoSchema(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string targetNamespace)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(targetNamespace));
			if (string.IsNullOrEmpty(targetNamespace))
				throw new global::System.ArgumentNullException("targetNamespace");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("NoSchema"),
					targetNamespace
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for schema validation error.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="message">Validation message reported from schema validation.</param>
		public static void SchemaValidationError(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string message)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(message));
			if (string.IsNullOrEmpty(message))
				throw new global::System.ArgumentNullException("message");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				message,
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an warning for unexpected XML element.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		public static void UnexpectedXmlElement(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
				
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("UnexpectedXmlElement"),
					reader.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		#endregion
	
		#region Errors
		/// <summary>
		/// Add an error for ambiguous moniker.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="moniker">The ambiguous moniker string.</param>
		/// <param name="element1">The first element using the given moniker.</param>
		/// <param name="element2">The second element using the given moniker.</param>
		public static void AmbiguousMoniker(DslModeling::SerializationContext serializationContext, string moniker, DslModeling::ModelElement element1, DslModeling::ModelElement element2)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			global::System.Diagnostics.Debug.Assert(element1 != null);
			if (element1 == null)
				throw new global::System.ArgumentNullException("element1");
			global::System.Diagnostics.Debug.Assert(element2 != null);
			if (element2 == null)
				throw new global::System.ArgumentNullException("element2");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("AmbiguousMoniker"),
					moniker,
					DslModeling::SerializationUtilities.GetElementName(element1),
					DslModeling::SerializationUtilities.GetElementName(element2)
				),
				null	// No location info available
			);
		}
		
		/// <summary>
		/// Add an error for not able to monikerize an instance of the given DomainClass.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="domainClassName">Name of the DomainClass whose instance cannot be monikerized.</param>
		public static void CannotMonikerizeElement(DslModeling::SerializationContext serializationContext, string domainClassName)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(domainClassName));
			if (string.IsNullOrEmpty(domainClassName))
				throw new global::System.ArgumentNullException("domainClassName");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext.Result,
				null,	/* no location available for this error, because save failed. */
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("CannotMonikerizeElement"),
					domainClassName
				),
				0,
				0
			);
		}
		
		/// <summary>
		/// Add an error for dangling relationship instance.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type name of the relationship.</param>
		public static void DanglingRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(relationshipType));
			if (string.IsNullOrEmpty(relationshipType))
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("DanglingRelationship"),
					relationshipType
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for invalid property value with given type.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <param name="propertyType">Type of the property.</param>
		/// <param name="value">Invalid value that causes this error.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the property, making it MemberInfo only adds confusion.")]
		public static void InvalidPropertyValue(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string propertyName, global::System.Type propertyType, string value)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(propertyType != null);
			if (propertyType == null)
				throw new global::System.ArgumentNullException("propertyType");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(propertyName));
			if (string.IsNullOrEmpty(propertyName))
				throw new global::System.ArgumentNullException("propertyName");
			#endregion
			
			if (value == null)
				value = "<null>";
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("InvalidPropertyValue"),
					value,
					propertyName,
					propertyType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for missing moniker.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="monikerAttributeName">Name of the attribute that should hold the moniker.</param>
		public static void MissingMoniker(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string monikerAttributeName)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerAttributeName));
			if (string.IsNullOrEmpty(monikerAttributeName))
				throw new global::System.ArgumentNullException("monikerAttributeName");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MissingMoniker"),
					monikerAttributeName
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for unresolved moniker.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to add the error message to.</param>
		/// <param name="moniker">Unresolved moniker.</param>
		public static void UnresolvedMoniker(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationResult,
				moniker.Location,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("UnresolvedMoniker"),
					moniker.MonikerName
				),
				moniker.Line,
				moniker.Column
			);
		}
	
		/// <summary>
		/// Add an error for Version mismatch.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="expectedVersion">The version that's expected.</param>
		/// <param name="actualVersion">Actual version from the file.</param>
		public static void VersionMismatch(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Version expectedVersion, global::System.Version actualVersion)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(expectedVersion != null);
			if (expectedVersion == null)
				throw new global::System.ArgumentNullException("expectedVersion");
			global::System.Diagnostics.Debug.Assert(actualVersion != null);
			if (actualVersion == null)
				throw new global::System.ArgumentNullException("actualVersion");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("VersionMismatch"), 
					actualVersion.ToString(4), 
					expectedVersion.ToString(4)
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		#endregion
	}
}


